id,title,content,summary,thumb,created_at,updated_at,views_count,likes_count,author_id,category_id,slug,md5_hash
1,Crafting a Best-Selling Solar E-Ink Weather Station,"## Introduction

With the increasing severity of climate change, people are paying more attention to the weather. As a result, more individuals are starting to install weather displays at home to stay informed about local meteorological conditions. This solar-powered electronic paper weather station perfectly meets this need. Its compact size allows for seamless integration into window frames, and its extremely low power consumption, coupled with solar charging capabilities, ensures long-term operation even without a stable power supply, making it a potential best-seller.

![[Pasted image 20240614190526.png]]

## Features and Characteristics

The concept of this weather station is to power the energy collection module with a solar cell. When the solar cell generates electricity, the energy collection module will charge. This energy collection method works even under very low solar input conditions, making it highly suitable for indoor energy collection. To reduce power consumption, the display can be turned off after updating, ensuring the battery lasts for a long time.

![[Pasted image 20240614190554.png]]

The weather station uses the ESP32 S3 Mini as the control core, paired with a Tri-Color ePaper 2.13 (SSD1680) shield display, which offers a clear display with extremely low power consumption. Its three monocrystalline silicon solar cells provide reliable charging capabilities, and with the SPV1050 micro solar power manager, ample power supply is ensured. The TPS73733DCQR low-dropout voltage regulator, a 1000uF 10V electrolytic capacitor, and the SPV1050 micro solar power manager enable efficient battery charging and energy management.

![[Pasted image 20240614190607.png]]

## Bill of Materials

- **Hardware Components**:
  - ESP32 S3 Mini: 1
  - Tri-Color ePaper 2.13 (SSD1680) Shield: 1
  - MONOCRYST SOLAR CELL 147MW 4.15V - SM111K06L: 3
  - SPV1050 Micro Solar Power Manager: 1
  - TPS73733DCQR Low-Dropout Voltage Regulator: 1
  - 1000uF 10V Electrolytic Capacitor: 1
  - 3D Printed Case: 1
  - M2*4 Flat Head Self-Tapping Screws: 2
  - M2*20 Flat Head Self-Tapping Screws: 4

- **Software Applications and Online Services**:
  - Arduino IDE

- **Hand Tools and Machinery**:
  - 3D Printer

## Production Process

Firstly, some modifications to the ESP 32 S3 Mini module are required, including removing the integrated RGB LED and replacing the voltage regulator.

![[Pasted image 20240614190623.png]]

Next, install the solar cells, micro solar power manager, and other components, and connect them according to the schematic diagram.

![[Pasted image 20240614190638.png]]

During installation, consider the cable length to ensure accurate connections between components.

![[Pasted image 20240614190653.png]]
## Advantages

- Solar-powered, energy-saving, and environmentally friendly
- Compact size, can be embedded in window frames
- Clear display effect, extremely low power consumption, capable of working under very low solar input conditions, and can operate for a long time

![[Pasted image 20240614190708.png]]
## Summary

The solar electronic paper weather station has the advantages of being compact, energy-saving, and easy to make and install. By utilizing solar charging and low-power design, this weather station is not only suitable for home use but also suitable for commercial and school settings. Although this is a quick prototype design, it can be further optimized for power consumption and functionality to meet the needs of different users in the future.

Project Address: [Solar E-Ink Weather Station on GitHub](https://github.com/rsappia/Solar_E-Ink_Weather_Station)",,,2024-11-25 12:45:52.740642,2025-07-28 02:02:56.995810,625,0,1,1,crafting-a-best-selling-solar-e-ink-weather-station,f187d81327e7c509cacc31749bd2b825
2,Bee-Counting,"BuzzTech: Machine Learning at the Edge: Deploying YOLOv8 on Raspberry Pi Zero 2W for Real-Time Bee Counting at the Hive Entrance

![[224dfd06928fd7f7ea74cdf271e5c8cd_MD5.png]]

## Introduction

At the Federal University of Itajuba in Brazil, with the master's student José Anderson Reis and Professor José Alberto Ferreira Filho, we are exploring a project that delves into the intersection of technology and nature. This tutorial will review our first steps and share our observations on deploying YOLOv8, a cutting edge machine learning model, on the compact and efficient Raspberry Pi Zero 2W (Raspi-Zero). We aim to estimate the number of bees entering and exiting their hive—a task crucial for beekeeping and ecological studies

Why is this important? Bee populations are vital indicators of environmental health, and their monitoring can provide essential data for ecological research and conservation efforts. However, manual counting is labor-intensive and prone to errors. By leveraging the power of embedded machine learning, or tinyML, we automate this process, enhancing accuracy and efficiency.

![[4f4ce468541ec97209246d0f8d7cfcb9_MD5.png]]

This tutorial will cover setting up the Raspberry Pi, integrating a camera module, optimizing and deploying YOLOv8 for real-time image processing, and analyzing the data gathered.

## Installing and using Ultralytics YOLOv8

[Ultralytics YOLOv8](https://github.com/ultralytics/ultralytics), is a version of the acclaimed real-time object detection and image segmentation model, YOLO. YOLOv8 is built on cutting-edge advancements in deep learning and computer vision, offering unparalleled performance in terms of speed and accuracy. Its streamlined design makes it suitable for various applications and easily adaptable to different hardware platforms, from edge devices to cloud APIs.

Let's start installing the Ultarlytics packages for local inference on the Rasp-Zero:

1. Update the packages list, install pip, and upgrade to the latest:
   
```powershell
sudo apt update
sudo apt install python3-pip -y
pip install -U pip
```

2. Install the ultralytics pip package with optional dependencies:

```powershell
pip install ultralytics
```

3. Reboot the device:

```powershell
 sudo reboot
```

## Testing the YOLO

After the Rasp-Zero booting, let's create a directory for working with YOLO and change the current location to it:

```powershell
mkdir Documents/YOLO
cd Documents/YOLO
```

Let's run inference on an image that will be downloaded from the Ultralytics website, using the YOLOV8n model (the smallest in the family) at the Terminal (CLI):

```powershell
yolo predict model=yolov8n-seg.pt source='https://ultralytics.com/images/bus.jpg' imgsz=640
```

The inference result will appear in the terminal:

> In the image (bus.jpg), 4 persons , 1 bus, and 1 stop signal were detected:

Also, we got a message that: 

> Results saved to runs/detect/predict4 . 

Inspecting that directory, we can see a new image saved (bus.jpg). Let's download it from the Rasp-Zero to our desktop for inspection:

![[8cbb78887147ac33ef5080e9163ada2d_MD5.gif]]

So, the Ultrayitics YOLO is correctly installed on our Rasp-Zero.

## Export Model to NCNN format

An issue is the high latency for this inference,  7.6 s, even with the smaller model of the family (YOLOv8n). This is a reality of deploying computer vision models on edge devices with limited computational power, such as the Rasp-Zero. One alternative is to use a format optimized for optimal performance. This ensures that even devices with limited processing power can handle advanced computer vision tasks well.

Of all the model export formats supported by Ultralytics, the [NCNN](https://docs.ultralytics.com/integrations/ncnn) is a high-performance neural network inference computing framework optimized for mobile platforms. From the beginning of the design, NCNN was deeply considerate about deployment and use on mobile phones and did not have third-party dependencies. It is cross-platform and runs faster than all known open-source frameworks (such as TFLite).

NCNN delivers the best inference performance when working with Raspberry Pi devices. NCNN is highly optimized for mobile embedded platforms (such as ARM architecture).

So, let's convert our model and rerun the inference:

1. Export a YOLOv8n PyTorch model to NCNN format, creating:  '/yolov8n_ncnn_model'

```
yolo export model=yolov8n.pt format=ncnn
```

2. Run inference with the exported model (now the source could be the bus.jpg image that was downloaded from the website to the current directory on the last inference):

```
yolo predict model='./yolov8n_ncnn_model' source='bus.jpg'
```

Now, we can see that the latency was reduced by half.

![[49c9586e79504442f3156ceefc241b28_MD5.gif]]

## Estimating the number of Bees  

For our project at the university, we are preparing to collect a dataset of bees at the entrance of a beehive using the same camera connected to the Rasp-Zero. The images should be collected every 10 seconds. With the Arducam OV5647, the horizontal Field of View (FoV)  is 53.5o, which means that a camera positioned at the top of a standard Hive (46 cm) will capture all of its entrance (about 47 cm).  

![[2fd8ef962de1c80fe10c5bd2cc802b3e_MD5.jpg]]

## Dataset

The dataset collection is the most critical phase of the project and should take several weeks or months. For this tutorial, we will use a public dataset: ""Sledevic, Tomyslav (2023), “[Labeled dataset for bee detection and direction estimation on beehive landing boards,” Mendeley Data, V5, doi: 10.17632/8gb9r2yhfc.5""

The original dataset has 6,762 images (1920 x 1080), and around 8% of them (518) have no bees (only background). This is very important with Object Detection, where we should keep around 10% of the dataset with only background (without any objects to be detected).

The images contain from zero to up to 61 bees:

![[846c059fea0cf64acdd312c0286f20bc_MD5.jpg]]

We downloaded the dataset (images and annotations) and uploaded it to [Roboflow](https://roboflow.com/). There, you should create a free account and start a new project, for example, (`Bees_on_Hive_landing_boards`):

![[cee525361ac9969482f5bd3eb089a026_MD5.gif]]We will not enter details about the Roboflow process once many tutorials are available.

Once the project is created and the dataset is uploaded, you should review the annotations using the ""AutoLabel"" Tool. Note that all images with only a background should be saved w/o any annotations. At this step, you can also add additional images.

![[54a3144a079e110b7ba316f6456a9bcb_MD5.gif]]

Once all images are annotated, you should split them into training, validation, and testing.

![[ff2b450fd65fa9c958138f3add87327d_MD5.gif]]

## Pre-Processing                                           

The last step with the dataset is preprocessing to generate a final version for training. The Yolov8 model can be trained with 640 x 640 pixels (RGB) images. Let's resize all images and generate augmented versions of each image (augmentation) to create new training examples from which our model can learn.

For augmentation, we will rotate the images (+/-15o) and vary the brightness and exposure.

![[ac7725c21ffa27f6e3b74e176c75d6cf_MD5.gif]]

This will create a final dataset of 16,228 images.

![[aa30e5cc1cd3d20083ea30eaa9686e6f_MD5.jpg]]

Now, you should export the model in a YOLOv8 format. You can download a zipped version of the dataset to your desktop or  get a downloaded code to be used with a Jupyter Notebook:

![[fde8eb872c3475cecd312d3f8cb4e003_MD5.jpg]]

And that is it! We are prepared to start our training using Google Colab.

The pre-processed dataset can be found at the [Roboflow site](https://universe.roboflow.com/marcelo-rovai-riila/bees_on_hive_landing_boards).

## Training YOLOv8 on a Customized Dataset                                                         

For training, let's adapt one of the public examples available from Ultralitytics and run it on Google Colab:

![[466859c26ee06080096938f8fa6560e3_MD5.gif]] ![[clip_image059.gif]]  yolov8_bees_on_hive_landing_board.ipynb [Open](https://colab.research.google.com/github/Mjrovai/Bee-Counting/blob/main/yolov8_bees_on_hive_landing_board.ipynb) [](https://colab.research.google.com/github/Mjrovai/Bee-Counting/blob/main/yolov8_bees_on_hive_landing_board.ipynb)[in](https://colab.research.google.com/github/Mjrovai/Bee-Counting/blob/main/yolov8_bees_on_hive_landing_board.ipynb) [](https://colab.research.google.com/github/Mjrovai/Bee-Counting/blob/main/yolov8_bees_on_hive_landing_board.ipynb)[C](https://colab.research.google.com/github/Mjrovai/Bee-Counting/blob/main/yolov8_bees_on_hive_landing_board.ipynb)[o](https://colab.research.google.com/github/Mjrovai/Bee-Counting/blob/main/yolov8_bees_on_hive_landing_board.ipynb)[lab](https://colab.research.google.com/github/Mjrovai/Bee-Counting/blob/main/yolov8_bees_on_hive_landing_board.ipynb)

**Critical points on the Notebook:**                       

![[910a9a6b9245e5b7fe6d75bb6f2bec6e_MD5.gif]]

![[clip_image063.gif]]

5. Define the main hyperparameters that you want to change from default, for example:

![[clip_image064.gif]]

6. Run the training (using CLI):

![[clip_image067.gif]]

7. Note that the trained model ( best.pt ) is saved in the folder  /runs/detect/train3/weights/ . Now, you should validade the trained model with the valid/images .

!yolo task=detect mode=val model={HOME}/runs/detect/train3/weights/best.pt data=

{dataset.location}/data.yaml

The results were similar to training.

8. Now, we should perform inference on the images left aside for testing

![[clip_image069.gif]]

We can also perform inference with a completely new and complex image from another beehive with a different background (the beehive of Professor Maurilio of our University). The results were great (but not perfect and with a lower confidence score). The model found 41 bees.

![[aa27e90f38af461925cd62be14681cc0_MD5.jpg]]

9. The last thing to do is export the train, validation, and test results for your Drive at Google. To do so, you should mount your drive.

![[clip_image072.gif]]

# Inference with the trained model, using the Rasp-Zero         

Using the FileZilla FTP, let's transfer the best.pt to our Rasp-Zero (before the transfer, you may change the model name, for example, bee_landing_640_best.pt ).

The first thing to do is convert the model to an NCNN format: yolo export model=bee_landing_640_best.pt format=ncnn

As a result, a new converted model, bee_landing_640_best_ncnn_model is created in the same directory.

Let's create a folder to receive some test images (under Documents/YOLO/ :

![[clip_image073.gif]]

Using the FileZilla FTP, let's transfer a few images from the test dataset to our Rasp-Zero:

![[45550bdb9beaaa7bedd1d1d5d83f8e05_MD5.jpg]]

Let's use the Python Interpreter:

![[clip_image076.gif]]

As before, we will import the YOLO library and define our converted model to detect bees:

![[clip_image077.gif]]

Now, let's define an image and call the inference (we will save the image result this time to external verification):

img = 'test_images/15_bees.jpg'

result = model.predict(img, save=True, imgsz=640, conf=0.2, iou=0.3)

The inference result is saved on the variable result, and the processed image on runs/detect/predict9

![[cd32951c790b38efa87cfa5c41cd6209_MD5.gif]]

Using FileZilla FTP, we can send the inference result to our Desktop for verification:  

![[21283864b32979c4547bbe6041c99241_MD5.gif]]

let's go over the other images, analyzing the number of objects (bees) found:

![[bd38df960b929a118f9280428bf90165_MD5.gif]]

Depending on the confidence, we can have some false positives or negatives. But in general, with a model trained based on the smaller base model of the YOLOv8 family (YOLOv8n) and also converted to NCNN, the result is pretty good, running on an Edge device such as the Rasp-Zero. Also, note that the inference latency is around 730ms.

![[349038c77cbaa82a24f8924661a9ea41_MD5.gif]]For example, by running the inference on Maurilio-bee.jpeg , we can find 40 bees . During the test phase on Colab,  41 bees were found (we only missed one here.)

# Considerations about the Post-Processing                                       

Our final project should be very simple in terms of code. We will use the camera to capture an image every 10 seconds. As we did in the previous section, the captured image should be the input for the trained and converted model. We should get the number of bees for each image and save it in a database (for example, timestamp: number of bees).

We can do it with a single Python script or use a Linux system timer, like cron , to periodically capture images every 10 seconds and have a separate Python script to process these images as they are saved. This method can be particularly efficient in managing system resources and can be more robust against potential delays in image processing.

**Setting Up the Image Capture with** **cron**  

First, we should set up a cron job to use the rpicam-jpeg command to capture an image every 10 seconds.

1. **Edit the** **crontab** :

Open the terminal and type crontab -e to edit the cron jobs.

![[clip_image086.gif]]cron normally doesn't support sub-minute intervals directly, so we should use a workaround like

a loop or watch for file changes.

2. **Create a Bash Script (** **capture.sh )**:

![[clip_image087.gif]]![[clip_image088.gif]]   **Image Capture**: This bash script captures images every 10 seconds using rpicam-jpeg , a command that is part of the raspijpeg tool. This command lets us control the camera and capture JPEG images directly from the command line. This is especially useful because we are looking for a lightweight and straightforward method to capture images without the need for additional libraries like Picamera or external software. The script also saves the captured image with a timestamp.

**Setting Up the Python Script for Inference**     

**Image Processing**: The Python script continuously monitors the designated directory for new images, processes each new image using the YOLOv8 model, updates the database with the count of detected bees, and optionally deletes the image to conserve disk space.

**Database Updates**: The results, along with the timestamps, are saved in an SQLite database. For that, a simple option is to use [sqlite3](https://docs.python.org/3/library/sqlite3.html).

In short, we need to write a script that continuously monitors the directory for new images, processes them using a YOLO model, and then saves the results to a SQLite database. Here’s how we can create and make the script executable:

![[clip_image089.gif]]

![[3848f9cc50dd349a0ed55c2c12095302_MD5.gif]]

The python script must be executable, for that:

1. **Save the script**: For example, as process_images.py .

2. **Change file permissions** to make it executable:

![[clip_image092.gif]]

![[clip_image093.gif]]

or

![[clip_image063.gif]]

Note that we are capturing images with their own timestamp and then log a separate timestamp for when the inference results are saved to the database. This approach can be beneficial for the following reasons:

1. **Accuracy in Data Logging**:

![[clip_image094.gif]]   **Capture Timestamp**: The timestamp associated with each image capture represents the exact moment the image was taken. This is crucial for applications where precise timing of events (like bee activity) is important for analysis.

![[clip_image088.gif]]   **Inference Timestamp**: This timestamp indicates when the image was processed and the results were recorded in the database. This can differ from the capture time due to processing delays or if the image processing is batched or queued.

2. **Performance Monitoring**:

![[clip_image094.gif]]   Having separate timestamps allows us to monitor the performance and efficiency of your image processing pipeline. We can measure the delay between image capture and result logging, which helps optimize the system for real-time processing needs.

3. **Troubleshooting and Audit**:

![[clip_image094.gif]]   Separate timestamps provide a better audit trail and troubleshooting data. If there are issues with the image processing or data recording, having distinct timestamps can help isolate whether delays or problems occurred during capture, processing, or logging.

## Script For Reading the SQLite Database                                                     

Here is an example of a code to retrieve the data from the database:

```python
#!/usr/bin/env python3
import sqlite3
def main():
  db_path = 'bee_count.db'
  conn = sqlite3.connect(db_path)
  cursor = conn.cursor()
  query = ""SELECT * FROM bee_counts""
  cursor.execute(query)
  data = cursor.fetchall()
  for row in data:
  print(f""Timestamp: {row[0]}, Number of bees: {row[1]}"")
  conn.close()
if __name__ == ""__main__"":
  main()
```

## Adding Environment data                       

Besides bee counting, environmental data, such as temperature and humidity, are essential for monitoring the bee-have health. Using a Rasp-Zero, it is straightforward to add a digital sensor such as the DHT-22 to get this data.

![[001a7f50d4b8fe391ebe9a34f43bead4_MD5.jpg]]

Environmental data will be part of our final project. If you want to know more about connecting sensors to a Raspberry Pi and, even more, how to save the data to a local database and send it to the web, follow this tutorial: [From Data to Graph: A Web Journey With Flask and SQLite](https://www.hackster.io/mjrobot/from-data-to-graph-a-web-journey-with-flask-and-sqlite-4dba35).

![[2c6257d2b2727875169d6f6e89e1780e_MD5.jpg]]

# Conclusion                                      

In this tutorial, we have thoroughly explored integrating the YOLOv8 model with a Raspberry Pi Zero 2W to address the practical and pressing task of counting (or better, ""estimating"") bees at a beehive entrance. Our project underscores the robust capability of embedding advanced machine learning technologies within compact edge computing devices, highlighting their potential impact on environmental monitoring and ecological studies.

This tutorial provides a step-by-step guide to the practical deployment of the YOLOv8 model. We demonstrate a tangible example of a real-world application by optimizing it for edge computing in terms of efficiency and processing speed (using NCNN format). This not only serves as a functional solution but also as an instructional tool for similar projects.

The technical insights and methodologies shared in this tutorial are the basis for the complete work to be developed at our university in the future. We envision further development, such as integrating additional environmental sensing capabilities and refining the model's accuracy and processing efficiency.

Implementing alternative energy solutions like the proposed solar power setup will expand the project's sustainability and applicability in remote or underserved locations.

The Dataset paper, Notebooks, and PDF version are in the [Project repository](https://github.com/Mjrovai/Bee-Counting).

On the [Tiny ML4D website](https://tinyml.seas.harvard.edu/courses/), you can find lots of educational materials on TinyML. They are all free and opensource for educational uses—we ask that if you use the material, please cite it! TinyML4D is an initiative to make TinyML education available to everyone globally.",,,2024-11-25 12:45:52.773841,2025-07-27 22:51:32.715579,903,0,1,1,bee-counting,ded5fc161c13c8d81b6a296b9b23b18a
3,smart alarm clock with ESP32,"## Introduction

This open-source project demonstrates how to build a multifunctional smart alarm clock using ESP8266 or ESP32 microcontrollers, featuring a network interface, sunrise wake-up light, and temperature display.

![[5eaec88c80ed822e3286086a397e3f15_MD5.webp]]

The project will guide you step by step through the development process of implementing advanced features for the alarm clock using ESP8266 or ESP32, including web interface configuration, multiple (cyclic) alarms, triggers, and information display.

![[04063f9883356ddd20e1d4a539ab9236_MD5.png]]
## Hardware Preparation

- Wemos D1 Mini or any ESP8266/ESP32 development board
  ![[ac5a4d38eaa31eac457621cf5437994e_MD5.png]]
- MAX7219 8x8 LED matrix module
- Rotary encoder with buttons
  ![[97e648fae24f766cade254d6e352e944_MD5.png]]
- Buzzer
- Photocell (optional)
- PIR motion sensor (optional)
- NeoPixel LED strip or ring (optional)
- BME280 sensor (optional)
  ![[99663cdc44677957f2aa87b3cc806aaf_MD5.png]]

## Software and Tools

- Arduino IDE
- ESPUI Library
![[172c899a20fa46db99b5fa8ce5e7ac0b_MD5.png]]
- ArduinoJSON Library
- FastLED Library (for controlling NeoPixel)

## Feature Highlights

- Support for ESP8266 and ESP32 development boards
- WiFi setup and time synchronization through a web interface
![[7dca639f5dcb9c3ebb81a1db5a451024_MD5.png]]
- Web interface for programming and modifying alarm settings
- Multiple alarm settings, with default support for 12
- Simulated sunrise with NeoPixel wake-up light function
- EEPROM storage that preserves settings after power loss
- Customizable message and duration for each alarm
![[4eb784305b728961c9e3397d856eabf4_MD5.png]]
- GPIO control upon alarm trigger to manage external devices
- Recurring alarms: repeat weekly, on weekdays, weekends, or custom intervals
- 5 time display modes, including AM/PM mode
- Support for OTA (Over-The-Air) updates
- BME280 sensor support for displaying temperature, humidity, and pressure
- Passive Infrared (PIR) sensor for motion detection with message and sound alerts
![[4357e671f56d0924bf9c766338a921ed_MD5.png]]
- Sleep mode and suspend mode for the display
- Customizable melodies, such as Big Ben, Avicii, etc.
- Photocell sensor support for adjusting LED brightness based on light levels
- Motion sensor support

## Assembly Steps

### 1. Hardware Connection

Firstly, connect all hardware components according to the provided schematic. This includes connecting the LED matrix module, rotary encoder, buzzer, and other sensors to the ESP32 development board.

![[04eb8c034e3e7b84d8288d771c974038_MD5.webp]]

![[a966c744141e459eb7c87a524ec8c69c_MD5.webp]]
### 2. Software Setup

Use the Arduino IDE to install the required library files and download the code ZIP file, ensuring all feature files and the main file are in the same folder so they can be opened as tabs in the IDE. The required open-source code addresses are:

- [Adafruit-GFX-Library](https://github.com/adafruit/Adafruit-GFX-Library)
- [arduino-Max72xxPanel](https://github.com/markruys/arduino-Max72xxPanel)
- [RotaryEncoder](https://github.com/mathertel/RotaryEncoder)
- [ESPUI](https://github.com/s00500/ESPUI)

### 3. Code Adjustment

Based on your own hardware setup, you will need to search for `@EB-setup` comments in the code to adjust the hardware pins and other settings. If you need to modify the default settings, you can search for `@EB-custom` comments.

### 4. Network Interface Configuration

Upon startup, the alarm clock will attempt to read the WiFi configuration from the EEPROM and connect to the network. If there are no stored settings, or if the network name or password has changed, it will create a hotspot for you to enter new settings, which will then be saved to the EEPROM.

![[2fc27308ea8755e1e393c77a9497748a_MD5.webp]]
### 5. Web Interface Usage

After connecting to the network created by the ESP32, you can access the web interface to configure the alarm clock, including setting the time, alarms, display modes, etc.

![[9f3a0b1f1b23f5c91879a0a32c8d809e_MD5.png]]
## Debugging and Testing

Once your hardware and software are ready, ensure thorough testing to verify all functions of the alarm clock. Check the network connection, responsiveness of the web interface, accuracy of sensor readings, and reliability of the alarm functions.

## Conclusion

Through this tutorial, you will not only be able to create a multifunctional smart alarm clock but also learn the basics of ESP32, including hardware interfaces, network programming, and sensor integration. This project is not only an interesting DIY activity but also brings convenience and fun to your daily life.

Project code: [Baidu Pan Link](https://pan.baidu.com/s/1XN6CCODmnHrjzyVo89YMaQ?pwd=1234)",,,2024-11-25 12:45:52.798743,2025-07-27 23:22:53.722015,1704,0,1,1,smart-alarm-clock-with-esp32,5b7b28a03306ec2715e089abd200cf37
4,ESPUI,"## What is ESPUI

ESPUI is a simple web user interface library designed for ESP32 and ESP8266 devices. It enables users to easily create and manage the web interface of their devices without any HTML, CSS, or JavaScript front-end development knowledge. The ESPUI library allows users to easily communicate and control their devices through a web browser, providing a convenient and intuitive operation interface.

![[fb0011b0003fbd680b585efc171c07f7_MD5.webp]]

**Features of ESPUI**

1. **Easy to use**: ESPUI provides simple and easy-to-understand APIs that users can easily use to create their own web interfaces without mastering professional front-end development knowledge.

2. **Flexible customization**: The ESPUI library allows users to customize the web interface according to their needs, including style, layout, and functionality.

3. **Lightweight**: The ESPUI library is small in size and has high running efficiency, which can run on resource-constrained microcontrollers.

4. **Support for various controls**: The ESPUI library provides a rich set of controls, including text boxes, buttons, sliders, etc., to meet users' various needs for web interfaces.

![[69f600b465480ea03601be26535d41c7_MD5.gif]]

**Installation**

ESPUI can be found on GitHub or installed using the Arduino Library Manager. To install ESPUI using the Arduino Library Manager, follow these steps:

1. Open the Arduino IDE.
2. Click the ""Sketch"" menu, then select ""Include Library"" -> ""Manage Libraries"".
3. Enter ""ESPUI"" in the search box and click ""Install"".

![[52285ba114328c6055e8b82812f0bf07_MD5.webp]]

## Usage

### 1. Create a Web Server

First, we need to create a web server. You can use the following code:

```cpp
#include <ESPUI.h>

ESPUI ui;

void setup() {
  ui.begin();
}

void loop() {
  ui.loop();
}
```

This code creates a web server and stores it in the variable `ui`.

### 2. Add Web Pages

Next, we need to add web pages to the web server. You can use the following code:

```cpp
#include <ESPUI.h>

ESPUI ui;

void setup() {
  ui.begin();

  // Create a web page named ""index""
  ESPUI_Page page = ui.addPage(""index"");

  // Add a text element to the web page
  ESPUI_Text text = page.addText(""Hello, world!"");
}

void loop() {
  ui.loop();
}
```

This code adds a web page named `""index""` to the web server and adds a text element `""Hello, world!""` to the page.

### 3. Handle HTTP Requests

When the client sends an HTTP request to the web server, ESPUI will call the `handleHTTPRequest` function. We can use this function to handle HTTP requests. You can use the following code:

```cpp
#include <ESPUI.h>  
  
ESPUI ui;  
  
void setup() {  
  ui.begin();  
  
  // Create a web page named ""index""
  ESPUI_Page page = ui.addPage(""index"");  
  
  // Add a text element to the web page
  ESPUI_Text text = page.addText(""Hello, world!"");  
}  
  
void handleHTTPRequest(ESPUI_HttpRequest request) {  
  // Check the URI of the request
  if (request.getURI() == ""/hello"") {  
    // Send ""Hello, world!"" response
    request.sendResponse(200, ""text/plain"", ""Hello, world!"");  
  } else {  
    // Send 404 error response
    request.send404();  
  }  
}  
  
void loop() {  
  ui.loop();  
}
```

The code defines a function `handleHTTPRequest`, which is called when a client sends an HTTP request to the web server. The function checks the URI of the request; if the requested URI is `""/hello""`, it sends a `""Hello, world!""` response; otherwise, it sends a 404 error response.

![[02b0d0e3b7840f72210312dfa782fccf_MD5.webp]]

**ESPUI Application Scenarios**

1. **Internet of Things (IoT) Device Control**: The ESPUI library is suitable for remote control of IoT devices, allowing users to manipulate various functions of devices through a web interface.

2. **Smart Home Systems**: The ESPUI library can be used for control panels in smart home systems, enabling users to remotely control various devices in the home from mobile phones, computers, and other devices.

3. **Embedded System Management**: The ESPUI library can also be used for remote management of embedded systems, allowing users to configure and monitor embedded devices through a web interface.

![[20796d191b4e8a8a104f6aaa95e67a14_MD5.webp]]

**Conclusion**

ESPUI is a simple yet powerful network user interface library, providing convenient web interface control capabilities for ESP32 and ESP8266 devices. It can help users quickly create and customize their own web interfaces, making device operations more convenient and intuitive. The emergence of the ESPUI library will undoubtedly bring greater convenience and possibilities to the development and application of IoT devices.

Project Address: [https://github.com/s00500/ESPUI](https://github.com/s00500/ESPUI)",,,2024-11-25 12:45:52.820379,2025-07-28 01:40:33.476728,940,0,1,1,espui,5a7486d044a7a565d7c1f88b5613549e
5,Minimalistic Messenger,"**Original Project Title**: ESP32 - Minimalistic Messenger

**Project Author**: Volos Projects

## Introduction

Hello everyone! This time, we're sharing a project that uses ESP-NOW for bidirectional communication.

![[0e76b7e1092b51c42c656e2601f2fd6f_MD5.png]]

The author has crafted these simple devices capable of sending brief text messages to each other using the ESP-NOW protocol. The operation is handled by the M5Stack Atom S3 development board.

![[d64e8a957cf040513aced6038eab822e_MD5.png]]

## Device Functionality Overview

The author demonstrates how to use these two devices for simple text communication. By inputting a message, such as ""hello how are you,"" and sending it to the other device, the recipient can receive and reply with a message like ""I'm great, thanks."" These messages are displayed in different colors on both devices to differentiate between received and sent messages.

## Technical Implementation and Challenges

This project utilizes two devices connected via ESP to send simple messages. The author learned how to implement bidirectional ESP communication by reading online tutorials. The challenge of this project was to use a compact M5 Stack Atom S3 development board equipped with a built-in 128x128 display, infrared LED, buttons, accelerometer, gyroscope, and other functionalities of the ESP32 device. To meet the project requirements, a simple PCB board was designed.

![[c9237f3ec7ed5792adf623594c62d934_MD5.png]]

The author aimed to make the device as small as possible, opting for the M5 Atom development board. Although a larger development board with a touchscreen or an M5 card computer might have been better options, the author preferred the current design. The display part of the device can only show the four most recent messages, with each message limited to 20 characters, and there is no scrolling system. The keyboard design is also very simple but sufficient for basic communication.

The device can serve as a great learning tool or a children's toy, while also offering some entertainment value to the project creators. The author also mentioned a comment emphasizing that the joy of the journey and learning process surpasses the destination itself.

## Resources

**GitHub Code Link**: [Messenger](https://github.com/VolosR/Messenger/)

**Author's PCB Material**: [Mini ESP32 Comunicactors](https://www.pcbway.com/project/shareproject/Mini_ESP32_Comunicactors_46e3a05a.html)",,,2024-11-25 12:45:52.839847,2025-07-28 00:08:26.057060,786,0,1,1,minimalistic-messenger,b6b5d154260cfc70b6b83c4f731d4c1f
6,Real-Time Display of ESP32-CAM Camera Images on TFT Screen,"## Preface

In the era of the Internet of Things (IoT), displaying images captured by a camera in real-time on a TFT screen has become a standard feature for many smart devices. ESP32, as a powerful microcontroller with a rich set of interfaces and strong processing capabilities, is an ideal choice for implementing this functionality. This article will provide a detailed introduction to an open-source project based on ESP32 for real-time display of camera images on a TFT screen, along with detailed steps to help you quickly build your own intelligent display system.

## Project Overview

The project, named ""camera-tft-esp32,"" was published on GitHub by developer San279. It aims to provide users with a simple and easy-to-use solution for displaying images captured by an ESP32 camera in real-time on an ST7789-driven or other TFT screens. The project code is concise and easy to understand, with detailed comments to facilitate user comprehension and modification.

![[fbf5e979cd394eb4c7e72b73957189cf_MD5.png]]

## Project File Description

- **camera-to-tft:** This folder contains the Arduino code for real-time display of camera images on the TFT screen.
- **User_Setup.h:** This file includes configuration information such as driver type, pin definitions, and resolution. It needs to be placed in the TFT_eSPI library.

## Project Execution Steps

1. **Download the Project:** Download the project files from the GitHub repository and unzip them into the Arduino IDE directory.
2. **Install the TFT_eSPI Library:** Download the TFT_eSPI library from the Arduino IDE's library manager or the GitHub repository. If downloading from GitHub, use the zip file to add a custom library.
3. **Replace User_Setup.h:** Replace the User_Setup.h file in the project files with the one in the TFT_eSPI library. Modify the relevant configurations in the User_Setup.h file if different ESP32 pin definitions, driver types, or resolutions are used.
4. **Configure the ESP32 Development Environment:** In the Arduino IDE, select settings that match your ESP32 development board model and ensure OPI PSRAM is enabled.
5. **Upload the Code:** Upload the code to the ESP32 development board to complete the project configuration.

## Project Code Analysis

The project primarily uses the following libraries to implement its functionality:

- **TFT_eSPI:** For controlling the display on the TFT screen.
- **Camera:** For controlling the camera to capture images.

The core part of the project code involves initializing the camera with the `Camera.begin()` function and using the `tft.pushImage()` function to display the image data captured by the camera in real-time on the TFT screen.

## Project Application Scenarios

The project can be applied to various scenarios, such as:

- **Smart Home:** Display images captured by the camera in real-time on the TFT screen of smart home devices for remote monitoring and visual control.
- **Industrial Automation:** Display images captured by the camera in real-time on the TFT screen of industrial equipment for visual monitoring of the production process and fault diagnosis.
- **Robot Vision:** Display images captured by the camera in real-time on the TFT screen of robots for target recognition and path planning.

## Conclusion

This project provides users with a simple and easy-to-use solution for displaying images captured by an ESP32 camera in real-time on a TFT screen. The project code is concise and easy to understand, with detailed comments, making it convenient for users to understand and modify. The project can be applied to various scenarios, such as smart homes, industrial automation, and robot vision, providing users with a powerful tool to easily achieve the functionality of real-time display of ESP32 camera images on a TFT screen, and offering a rich space for expansion.

**Project Address:** [camera-tft-esp32](https://github.com/San279/camera-tft-esp32)",,,2024-11-25 12:45:52.862763,2025-07-28 01:44:52.897726,1515,0,1,1,real-time-display-of-esp32-cam-camera-images-on-tft-screen,5008472ae4ba22e81df4928160a71e63
7,Markdown format support testing,"***
___

## Inline

`inline block`

<cite>citation</cite>

This is a ==mark (with **bold** *italic* `code`)== tag.

~~strike~~

**bold 1** and __bold 2__

*italic 1*  and _italic 2_

***bold 1 and italic 1***

## Links
Footnote and reference sources are at the bottom of the page.

Footnotes[^1] have a label[^@#$%] and the footnote's content.

[^1]: This is a footnote content.
[^@#$%]: A footnote on the label: ""@#$%"".

![A Picture](/uploads ""A Picture"")

[Link to Picture](/uploads ""Link"")

www.google.com

isaacmuse@gmail.com

https://github.com/facelessuser/pymdown

This is a link https://github.com/facelessuser/pymdown.

This is a link ""https://github.com/facelessuser/pymdown"".

With this link (https://github.com/facelessuser/pymdown), it still works.


## Unordered List


Unordered List

- item 1
    * item A
    * item B
        more text
        + item a
        + item b
        + item c
    * item C
- item 2
- item 3


## Ordered List

Ordered List

1. item 1
    1. item A
    2. item B
        more text
        1. item a
        2. item b
        3. item c
    3. item C
2. item 2
3. item 3

## Task List


Task List

- [X] item 1
    * [X] item A
    * [ ] item B
        more text
        + [x] item a
        + [ ] item b
        + [x] item c
    * [X] item C
- [ ] item 2
- [ ] item 3

## Mixed Lists
Mixed Lists

- item 1
    * [X] item A
    * [ ] item B
        more text
        1. item a
        2. item b
        3. item c
    * [X] item C
- item 2
- item 3


## Blocks

Normal raw block

    This is a block.

    This is more of a block.

Highlighted code block

    :::javascript
    // Fenced **with** highlighting
    function doIt() {
        for (var i = 1; i <= slen ; i^^) {
            setTimeout(""document.z.textdisplay.value = newMake()"", i*300);
            setTimeout(""window.status = newMake()"", i*300);
        }
    }


```cpp
#include <ESPUI.h>

ESPUI ui;

void setup() {
  ui.begin();
}

void loop() {
  ui.loop();
}
```

## Block Quotes


> This is a block quote.

> > How does it look?
> > <cite>--I said this too</cite>

> I think it looks good.
> <cite>--I said this</cite>

## Fenced Block

```javascript
// Fenced **with** highlighting
function doIt() {
    for (var i = 1; i <= slen ; i^^) {
        setTimeout(""document.z.textdisplay.value = newMake()"", i*300);
        setTimeout(""window.status = newMake()"", i*300);
    }
}
```

## Tables



| _Colors_      | Fruits          | Vegetable         |
| ------------- |:---------------:| -----------------:|
| Red           | *Apple*         | [Pepper](#Tables) |
| ~~Orange~~    | `Oranges`       | **Carrot**        |
| Green         | ~~***Pears***~~ | Spinach           |


## Admonition

/// note | Some title
Some content
///


///  Caution ""Warning!""
    - [X] Make sure you turn off the stove
    - [X] Don't run with scissors
/// 

## Github Emoji


This is a test for emoji :smile:.  The emojis are images linked to github assets :octocat:.

# Math

Some Equations:

$$
E(\mathbf{v}, \mathbf{h}) = -\sum_{i,j}w_{ij}v_i h_j - \sum_i b_i v_i - \sum_j c_j h_j
$$

- Here are some more equations:

    $$
        \begin{align}
            p(v_i=1|\mathbf{h}) & = \sigma\left(\sum_j w_{ij}h_j + b_i\right) \\
            p(h_j=1|\mathbf{v}) & = \sigma\left(\sum_i w_{ij}v_i + c_j\right)
        \end{align}
    $$

- Inline equations: $p(x|y) = \frac{p(y|x)p(x)}{p(y)}$.

***
___

## Inline

`inline block`

<cite>citation</cite>

This is a ==mark (with **bold** *italic* `code`)== tag.

~~strike~~

**bold 1** and __bold 2__

*italic 1*  and _italic 2_

***bold 1 and italic 1***

## Links
Footnote and reference sources are at the bottom of the page.

Footnotes[^1] have a label[^@#$%] and the footnote's content.

[^1]: This is a footnote content.
[^@#$%]: A footnote on the label: ""@#$%"".

![A Picture](/uploads ""A Picture"")

[Link to Picture](/uploads ""Link"")

www.google.com

isaacmuse@gmail.com

https://github.com/facelessuser/pymdown

This is a link https://github.com/facelessuser/pymdown.

This is a link ""https://github.com/facelessuser/pymdown"".

With this link (https://github.com/facelessuser/pymdown), it still works.


## Unordered List


Unordered List

- item 1
    * item A
    * item B
        more text
        + item a
        + item b
        + item c
    * item C
- item 2
- item 3


## Ordered List

Ordered List

1. item 1
    1. item A
    2. item B
        more text
        1. item a
        2. item b
        3. item c
    3. item C
2. item 2
3. item 3

## Task List


Task List

- [X] item 1
    * [X] item A
    * [ ] item B
        more text
        + [x] item a
        + [ ] item b
        + [x] item c
    * [X] item C
- [ ] item 2
- [ ] item 3

## Mixed Lists
Mixed Lists

- item 1
    * [X] item A
    * [ ] item B
        more text
        1. item a
        2. item b
        3. item c
    * [X] item C
- item 2
- item 3


## Blocks

Normal raw block

    This is a block.

    This is more of a block.

Highlighted code block

    :::javascript
    // Fenced **with** highlighting
    function doIt() {
        for (var i = 1; i <= slen ; i^^) {
            setTimeout(""document.z.textdisplay.value = newMake()"", i*300);
            setTimeout(""window.status = newMake()"", i*300);
        }
    }


```cpp
#include <ESPUI.h>

ESPUI ui;

void setup() {
  ui.begin();
}

void loop() {
  ui.loop();
}
```

## Block Quotes


> This is a block quote.

> > How does it look?
> > <cite>--I said this too</cite>

> I think it looks good.
> <cite>--I said this</cite>

## Fenced Block

```javascript
// Fenced **with** highlighting
function doIt() {
    for (var i = 1; i <= slen ; i^^) {
        setTimeout(""document.z.textdisplay.value = newMake()"", i*300);
        setTimeout(""window.status = newMake()"", i*300);
    }
}
```

## Tables



| _Colors_      | Fruits          | Vegetable         |
| ------------- |:---------------:| -----------------:|
| Red           | *Apple*         | [Pepper](#Tables) |
| ~~Orange~~    | `Oranges`       | **Carrot**        |
| Green         | ~~***Pears***~~ | Spinach           |


## Admonition

/// note | Some title
Some content
///


///  Caution ""Warning!""
    - [X] Make sure you turn off the stove
    - [X] Don't run with scissors
/// 

## Github Emoji


This is a test for emoji :smile:.  The emojis are images linked to github assets :octocat:.

# Math

Some Equations:

$$
E(\mathbf{v}, \mathbf{h}) = -\sum_{i,j}w_{ij}v_i h_j - \sum_i b_i v_i - \sum_j c_j h_j
$$

- Here are some more equations:

    $$
        \begin{align}
            p(v_i=1|\mathbf{h}) & = \sigma\left(\sum_j w_{ij}h_j + b_i\right) \\
            p(h_j=1|\mathbf{v}) & = \sigma\left(\sum_i w_{ij}v_i + c_j\right)
        \end{align}
    $$

- Inline equations: $p(x|y) = \frac{p(y|x)p(x)}{p(y)}$.

  - Markdown
summary: This is a testing post
thumb: 
---

This is a markdown support testing file.
## Headers

# H1
## H2
### H3

## Horizontal Rules

---

***
___

## Inline

`inline block`

<cite>citation</cite>

This is a ==mark (with **bold** *italic* `code`)== tag.

~~strike~~

**bold 1** and __bold 2__

*italic 1*  and _italic 2_

***bold 1 and italic 1***

## Links
Footnote and reference sources are at the bottom of the page.

Footnotes[^1] have a label[^@#$%] and the footnote's content.

[^1]: This is a footnote content.
[^@#$%]: A footnote on the label: ""@#$%"".

![A Picture](/uploads ""A Picture"")

[Link to Picture](/uploads ""Link"")

www.google.com

isaacmuse@gmail.com

https://github.com/facelessuser/pymdown

This is a link https://github.com/facelessuser/pymdown.

This is a link ""https://github.com/facelessuser/pymdown"".

With this link (https://github.com/facelessuser/pymdown), it still works.


## Unordered List


Unordered List

- item 1
    * item A
    * item B
        more text
        + item a
        + item b
        + item c
    * item C
- item 2
- item 3


## Ordered List

Ordered List

1. item 1
    1. item A
    2. item B
        more text
        1. item a
        2. item b
        3. item c
    3. item C
2. item 2
3. item 3

## Task List


Task List

- [X] item 1
    * [X] item A
    * [ ] item B
        more text
        + [x] item a
        + [ ] item b
        + [x] item c
    * [X] item C
- [ ] item 2
- [ ] item 3

## Mixed Lists
Mixed Lists

- item 1
    * [X] item A
    * [ ] item B
        more text
        1. item a
        2. item b
        3. item c
    * [X] item C
- item 2
- item 3


## Blocks

Normal raw block

    This is a block.

    This is more of a block.

Highlighted code block

    :::javascript
    // Fenced **with** highlighting
    function doIt() {
        for (var i = 1; i <= slen ; i^^) {
            setTimeout(""document.z.textdisplay.value = newMake()"", i*300);
            setTimeout(""window.status = newMake()"", i*300);
        }
    }


```cpp
#include <ESPUI.h>

ESPUI ui;

void setup() {
  ui.begin();
}

void loop() {
  ui.loop();
}
```

## Block Quotes


> This is a block quote.

> > How does it look?
> > <cite>--I said this too</cite>

> I think it looks good.
> <cite>--I said this</cite>

## Fenced Block

```javascript
// Fenced **with** highlighting
function doIt() {
    for (var i = 1; i <= slen ; i^^) {
        setTimeout(""document.z.textdisplay.value = newMake()"", i*300);
        setTimeout(""window.status = newMake()"", i*300);
    }
}
```

## Tables



| _Colors_      | Fruits          | Vegetable         |
| ------------- |:---------------:| -----------------:|
| Red           | *Apple*         | [Pepper](#Tables) |
| ~~Orange~~    | `Oranges`       | **Carrot**        |
| Green         | ~~***Pears***~~ | Spinach           |


## Admonition

/// note | Some title
Some content
///


///  Caution ""Warning!""
    - [X] Make sure you turn off the stove
    - [X] Don't run with scissors
/// 

## Github Emoji


This is a test for emoji :smile:.  The emojis are images linked to github assets :octocat:.

# Math

Some Equations:

$$
E(\mathbf{v}, \mathbf{h}) = -\sum_{i,j}w_{ij}v_i h_j - \sum_i b_i v_i - \sum_j c_j h_j
$$

- Here are some more equations:

    $$
        \begin{align}
            p(v_i=1|\mathbf{h}) & = \sigma\left(\sum_j w_{ij}h_j + b_i\right) \\
            p(h_j=1|\mathbf{v}) & = \sigma\left(\sum_i w_{ij}v_i + c_j\right)
        \end{align}
    $$

- Inline equations: $p(x|y) = \frac{p(y|x)p(x)}{p(y)}$.

  - Markdown
summary: This is a testing post
thumb: 
---

This is a markdown support testing file.
## Headers

# H1
## H2
### H3

## Horizontal Rules

---

***
___

## Inline

`inline block`

<cite>citation</cite>

This is a ==mark (with **bold** *italic* `code`)== tag.

~~strike~~

**bold 1** and __bold 2__

*italic 1*  and _italic 2_

***bold 1 and italic 1***

## Links
Footnote and reference sources are at the bottom of the page.

Footnotes[^1] have a label[^@#$%] and the footnote's content.

[^1]: This is a footnote content.
[^@#$%]: A footnote on the label: ""@#$%"".

![A Picture](/uploads ""A Picture"")

[Link to Picture](/uploads ""Link"")

www.google.com

isaacmuse@gmail.com

https://github.com/facelessuser/pymdown

This is a link https://github.com/facelessuser/pymdown.

This is a link ""https://github.com/facelessuser/pymdown"".

With this link (https://github.com/facelessuser/pymdown), it still works.


## Unordered List


Unordered List

- item 1
    * item A
    * item B
        more text
        + item a
        + item b
        + item c
    * item C
- item 2
- item 3


## Ordered List

Ordered List

1. item 1
    1. item A
    2. item B
        more text
        1. item a
        2. item b
        3. item c
    3. item C
2. item 2
3. item 3

## Task List


Task List

- [X] item 1
    * [X] item A
    * [ ] item B
        more text
        + [x] item a
        + [ ] item b
        + [x] item c
    * [X] item C
- [ ] item 2
- [ ] item 3

## Mixed Lists
Mixed Lists

- item 1
    * [X] item A
    * [ ] item B
        more text
        1. item a
        2. item b
        3. item c
    * [X] item C
- item 2
- item 3


## Blocks

Normal raw block

    This is a block.

    This is more of a block.

Highlighted code block

    :::javascript
    // Fenced **with** highlighting
    function doIt() {
        for (var i = 1; i <= slen ; i^^) {
            setTimeout(""document.z.textdisplay.value = newMake()"", i*300);
            setTimeout(""window.status = newMake()"", i*300);
        }
    }


```cpp
#include <ESPUI.h>

ESPUI ui;

void setup() {
  ui.begin();
}

void loop() {
  ui.loop();
}
```

## Block Quotes


> This is a block quote.

> > How does it look?
> > <cite>--I said this too</cite>

> I think it looks good.
> <cite>--I said this</cite>

## Fenced Block

```javascript
// Fenced **with** highlighting
function doIt() {
    for (var i = 1; i <= slen ; i^^) {
        setTimeout(""document.z.textdisplay.value = newMake()"", i*300);
        setTimeout(""window.status = newMake()"", i*300);
    }
}
```

## Tables



| _Colors_      | Fruits          | Vegetable         |
| ------------- |:---------------:| -----------------:|
| Red           | *Apple*         | [Pepper](#Tables) |
| ~~Orange~~    | `Oranges`       | **Carrot**        |
| Green         | ~~***Pears***~~ | Spinach           |


## Admonition

/// note | Some title
Some content
///


///  Caution ""Warning!""
    - [X] Make sure you turn off the stove
    - [X] Don't run with scissors
/// 

## Github Emoji


This is a test for emoji :smile:.  The emojis are images linked to github assets :octocat:.

# Math

Some Equations:

$$
E(\mathbf{v}, \mathbf{h}) = -\sum_{i,j}w_{ij}v_i h_j - \sum_i b_i v_i - \sum_j c_j h_j
$$

- Here are some more equations:

    $$
        \begin{align}
            p(v_i=1|\mathbf{h}) & = \sigma\left(\sum_j w_{ij}h_j + b_i\right) \\
            p(h_j=1|\mathbf{v}) & = \sigma\left(\sum_i w_{ij}v_i + c_j\right)
        \end{align}
    $$

- Inline equations: $p(x|y) = \frac{p(y|x)p(x)}{p(y)}$.",This post to show the support of Markdown format in the ESP32cube website.,,2024-11-25 12:45:52.898699,2025-07-27 22:48:02.676301,794,0,1,2,markdown-format-support-testing,082181bd0985b1136de6dc68bdce22ca
8,start,Move to this page https://esp32cube.com/post/esp32-read-pt1000pt100-temperature-sensor-values/,start,,2024-11-25 12:45:52.926425,2025-07-27 23:02:58.643717,1203,0,1,2,start,111cbbd9f87a8623617d53d1578e88d0
9,ESP32 DEVKIT V1 Pin Referance,"The first and most importance step for us to use a MCU is know what the peripherals and IOs it provided.

In this article, it will discuss the GPIO pin of ESP32 DevKit, we will know what it can do, and it can not.

!!! note

    In this article, it will discuss the ESP Devkit with 30 pins. Other revision develop board may have differnt configureation.

The ESP32 DEVKIT in our Amazone store is looks like this:

The general describe of ESP32 DevKit GPIO as below table.

| Function          | Description                                                                                                   |
| ----------------- | -------------------------------------------------------------------------------------------------------------- |
| 15 ADC channels   | 15 channels of 12-bit SAR ADC’s. The ADC range can be set, in firmware, to either 0-1V, 0-1.4V, 0-2V, or 0-4V |
| 2 UART interfaces | 2 UART interfaces. Commonly referred to as UART0 and UART1. One is used to load code serially.                 |
| 25 PWM outputs    | 25 channels can output PWM signal for LEDs or  motors controlling.                                             |
| 2 DAC channels    | 8-bit DACs to produce analog voltages output.                                                                  |
| 3 SPI interfaces  | 3 SPI interfaces.                                                                                              |
| 1 I2C interfaces  | 1 I2C interfaces                                                                                               |
| 9 Touch Pads      | 9 GPIOs feature capacitive touch sensing.                                                                      |

And notice that a single GPIO pin on the ESP32 can be configured to act as an ADC input, a DAC output, or a touchpad, depending on your needs.

## ESP32 DevKit Pinout

The ESP32 development board provides total 30 pins on two side of the board. It shows as below picture.

![[1672456581975.png]]

## GPIO Pins

ESP32 development board has 25 GPIO pins which can be assigned to various functions programmatically. Each digital enabled GPIO can be configured to internal pull-up or pull-down, or set to high impedance.

![[1672475264514.png]]

Which ESP32 GPIOs are safe to use?

Because the ESP32 has many pins with specific functions, they may not be suitable for your projects. The following table shows which pins are safe to use and which pins require more attention before using them.

 :material-check-circle:{ .success} Your first priority pins. They are perfectly

 :material-alert-circle:{ .warning} Pay attention as their behavior can be unpredictable, mainly during boot. Don’t use them unless you absolutely need to.

 :material-close-circle:{ .danger} It is not recommended to use these pins. So avoid them.

| Label | GPIO | Sign                               | Reason                                                                             |
| ----- | ---- | ---------------------------------- | ---------------------------------------------------------------------------------- |
| D0    | 0    | :material-alert-circle:{ .warning} | Reset pin. LOW for boot load. must not be left floating, a pull-up resistor and a ground capacitor are highly recommended.       |
| TX0   | 1    | :material-close-circle:{ .danger}  | Tx pin, used for flashing and debugging                                            |
| D2    | 2    | :material-alert-circle:{ .warning} | must be left floating or LOW to enter flashing mode, connected to the on-board LED |
| RX0   | 3    | :material-close-circle:{ .danger}  | Rx pin, used for flashing and debugging                                            |
| D4    | 4    | :material-check-circle:{ .success} |                                                                                    |
| D5    | 5    | :material-alert-circle:{ .warning} | must be HIGH during boot                                                           |
| D6    | 6    | :material-close-circle:{ .danger}  | Connected to Flash memory                                                          |
| D7    | 7    | :material-close-circle:{ .danger}  | Connected to Flash memory                                                          |
| D8    | 8    | :material-close-circle:{ .danger}  | Connected to Flash memory                                                          |
| D9    | 9    | :material-close-circle:{ .danger}  | Connected to Flash memory                                                          |
| D10   | 10   | :material-close-circle:{ .danger}  | Connected to Flash memory                                                          |
| D11   | 11   | :material-close-circle:{ .danger}  | Connected to Flash memory                                                          |
| D12   | 12   | :material-alert-circle:{ .warning} | must be LOW during boot                                                            |
| D13   | 13   | :material-check-circle:{ .success} |                                                                                    |
| D14   | 14   | :material-check-circle:{ .success} |                                                                                    |
| D15   | 15   | :material-alert-circle:{ .warning} | must be HIGH during boot, prevents startup log if pulled LOW                       |
| RX2   | 16   | :material-check-circle:{ .success} |                                                                                    |
| TX2   | 17   | :material-check-circle:{ .success} |                                                                                    |
| D18   | 18   | :material-check-circle:{ .success} |                                                                                    |
| D19   | 19   | :material-check-circle:{ .success} |                                                                                    |
| D21   | 21   | :material-check-circle:{ .success} |                                                                                    |
| D22   | 22   | :material-check-circle:{ .success} |                                                                                    |
| D23   | 23   | :material-check-circle:{ .success} |                                                                                    |
| D25   | 25   | :material-check-circle:{ .success} |                                                                                    |
| D26   | 26   | :material-check-circle:{ .success} |                                                                                    |
| D27   | 27   | :material-check-circle:{ .success} |                                                                                    |
| D32   | 32   | :material-check-circle:{ .success} |                                                                                    |
| D33   | 33   | :material-check-circle:{ .success} |                                                                                    |
| D34   | 34   | :material-alert-circle:{ .warning} | Input only GPIO, cannot be configured as output                                    |
| D35   | 35   | :material-alert-circle:{ .warning} | Input only GPIO, cannot be configured as output                                    |
| VP    | 36   | :material-alert-circle:{ .warning} | Input only GPIO, cannot be configured as output                                    |
| VN    | 39   | :material-alert-circle:{ .warning} | Input only GPIO, cannot be configured as output                                    |

### Input Only GPIOs

These pins cannot be configured as outputs:

* GPIO34
* GPIO35
* GPIO36(VP)
* GPIO39(VN)

they can be used as either digital inputs, analog inputs, or for other unique purposes. They do not have internal pull-up or pull-down resistors, like the other GPIO pins.

Also pins GPIO36(VP) and GPIO39(VN) are an integral part of the ultra-low-noise pre-amplifier for the ADC, which help to configure the sampling time and noise of the pre-amp.

### Interrupt Pins

Any GPIO pin on the ESP32 can be used for interrupts.

## Touch Pins

The ESP32 has a total of 10 internal capacitive touch sensors that can be used to detect touch input from user. These pins can be easily integrated into capacitive pads and replace mechanical buttons. The capacitive touch pins can also be used to wake up the ESP32 from deep sleep.

![[1672482956241.png]]

Those internal touch sensors are named as T0~T9, they according to these GPIOs:

- T0 (GPIO 4)
- T1 (GPIO 0)
- T2 (GPIO 2)
- T3 (GPIO 15)
- T4 (GPIO 13)
- T5 (GPIO 12)
- T6 (GPIO 14)
- T7 (GPIO 27)
- T8 (GPIO 33)
- T9 (GPIO 32)

## ADC Pins

On the ESP32, there are several ADC (Analog-to-Digital Converter) channels that can be used to measure analog voltages and convert them to digital values.

![[1672457037153.png]]

!!! warning

    The ADC2 pins cannot be used when Wi-Fi is enabled. If your project plans to use Wi-Fi, consider choosing ADC1 pins.

### ADC Resolution

On the ESP32, the ADC channels have a resolution of 12 bits, which means they can represent analog input values in the range of 0 to 4095 ($2^{12} - 1$) with increments of 1. This means that the analog input voltage can be measured with a resolution of approximately 0.8 mV (3.3V/4096) per step.

You can use the ESP32 Arduino core's `analogRead()` function to read the digital value of an analog input on one of the ADC channels.

It is important to note that the actual resolution of the ADC may be limited by other factors such as the noise and accuracy of the analog circuitry, as well as the stability and accuracy of the reference voltage used for the conversion.

It is recommended to add a 0.1 µF filter capacitor to a pad when using the ADC function.

The recommended input voltage of the ADC is below 2450 mV, and preferably within the range of 100 to
950 mV for higher calibration accuracy.

## DAC Pins

On the ESP32, there are two DAC (Digital-to-Analog Converter) channels that can be used to convert digital values to analog voltages.

The specific DAC channels and the associated GPIO pins on the ESP32 are as follows:

- DAC1 (GPIO 25)
- DAC2 (GPIO 26)

![[1672457924805.png]]

You can use the `dacWrite()` function to write a digital value to one of the DAC channels, which will be converted to an analog voltage and output on the corresponding GPIO pin.

It is important to note that the DAC channels on the ESP32 have a limited resolution and output range, and they may not be suitable for all analog output applications.

## SPI pins

ESP32 integrates 4 SPI:

- SPI0 and SPI1 used to connect with the flash memory of the chip. SPI0 and SP1 are not available to use.
- SPI2 and SPI3 are general-purpose SPI controllers.

SPI2, sometimes called HSPI. SPI3, sometimes called VSPI. The following table provides the default SPI pins for both channels.

![[1672472416689.png]]

| SPI Channel | MOSI / SDI | MISO / SDO | SCK/CLK | CS/SS  |
| ----------- | ---------- | ---------- | ------- | ------ |
| VSPI        | GPIO23     | GPIO19     | GPIO18  | GPIO5  |
| HSPI        | GPIO13     | GPIO12     | GPIO14  | GPIO15 |

We can also define other pins as SPI.

## I2C Pins

The ESP32 has a single default I2C bus. The SDA and SCL pins are, by default, assigned to the following pins. However, you can bit-bang the I2C protocol on any GPIO pins with `wire.begin(SDA, SCL)` command.

![[1672472830716.png]]

## UART Pins

ESP32 has 3 UART interfaces, UART0, UART1 and UART2, communicate at up to 5 Mbps.

- UART0 pins are connected to the USB-to-Serial converter and are used for flashing and debugging. It is not recommended to use the UART0 pins.
- UART2, on the other hand, are additional Serial1 pins, and are not connected to the USB-to-Serial converter.

![[1672472857790.png]]

A 499Ω resistor needs to be connected in series on the U0TXD line to suppress the 80 MHz harmonic.

It can also use other pin as TX and RX of UART. Such as below code, define RX to GPIO 26, TX to GPIO 27.

```
Serial.begin(115200,SERIAL_8N1,26,27);
```

## PWM pins

The ESP32 has total 16 PWM (pulse width modulation) channels that can be used to output PWM signals. These PWM channels are labeled 0 through 15 and are connected to various pins on the ESP32. The specific pins that can be used for PWM output depend on the pinout of the ESP32 board you are using.

Here is a list of the pins that can be used for PWM output on the ESP32:

* PWM0: IO4, IO10, IO12, IO13, IO14, IO15, IO27, IO32
* PWM1: IO5, IO9, IO11, IO13, IO15, IO26, IO33
* PWM2: IO6, IO8, IO10, IO12, IO14, IO25, IO34
* PWM3: IO7, IO8, IO9, IO11, IO13, IO24, IO35

![[1672475177813.png]]

The controller consists of PWM timers and the PWM operator. Each timer provides timing in synchronous or independent form, and each PWM operator generates the waveform for one PWM channel.

16 PWM (pulse width modulation) channels that can be used to output PWM signals. These PWM channels are labeled 0 through 15 and are connected to various pins on the ESP32. The specific pins that can be used for PWM output depend on the pinout of the ESP32 board you are using.

Here is a list of the pins that can be used for PWM output on the ESP32:

* PWM0: IO4, IO10, IO12, IO13, IO14, IO15, IO27, IO32
* PWM1: IO5, IO9, IO11, IO13, IO15, IO26, IO33
* PWM2: IO6, IO8, IO10, IO12, IO14, IO25, IO34
* PWM3: IO7, IO8, IO9, IO11, IO13, IO24, IO35","This article covers the ESP32 DEVKIT V1 pin reference, highlighting GPIO functions. The board has 30 pins and 25 GPIOs for various tasks, including ADC and DAC. Safety for each pin is discussed, aiding project development.",,2024-11-25 12:45:52.962211,2025-07-27 22:27:17.358112,2598,0,1,2,esp32-devkit-v1-pin-referance,1716cc1f68b66c19a8c6338669cefecf
10,How to Blink a LED with ESP32,"When we start play with a new hardware develop board, the first thing is make the LED blink. This never fails to excite us, and it's truly something worth showing off.

## 1. Component List

-   ESP32 Development Board
-   One LED (I used a 5mm red LED)
-   One 220-ohm Resistor
-   Breadboard
-   Several Jumper Wires

By the way, let me explain how to choose the current-limiting resistor for the LED and set an appropriate resistance value. We can find relevant parameters for the LED in its datasheet. To calculate the current-limiting resistor for the LED, the most important parameters are: Forward Voltage (VF), Forward Current (IF), and Peak Forward Current.

The LED's forward current can be taken as the peak value. However, to keep the operating current below the limit, you can calculate the current-limiting resistor using the following formula:

### Current Limiting Resistor = Power Supply Voltage - LED Forward Voltage / LED Forward Current

Of course, after calculating the resistance value for the current-limiting resistor, not all available resistor values in the market may match exactly. You need to choose a resistor that is close to the calculated value. After selecting a resistor value, recalculate to ensure that the LED's forward current and voltage remain within the limits.

Generally: 
- Red and green LEDs have a voltage of 1.8-2.4V.
- Blue and white LEDs have a voltage of 2.8-4.2V.
- Rated current for 3mm LEDs is 1-10mA.
- Rated current for 5mm LEDs is 5-25mA.
- Rated current for 10mm LEDs is 25-100mA.

## 2. Circuit Connection

![[LED1.png]]

## 3. LED Blinking Code

```arduino
/*******************************************************
   ESP32 LED Blinking
   Function: Blink the LED every second
   Pin: D18 (GPIO18)
*******************************************************/

int LED = 2;

void setup() {
  pinMode(LED, OUTPUT);
}

void loop() {
  digitalWrite(LED, HIGH); // Turn on the LED
  delay(1000); // Wait for a second
  digitalWrite(LED, LOW); // Turn off the LED
  delay(1000); // Wait for a second
}
```

When you see the above code, you'll notice that it's entirely identical to the ESP8266 and Arduino syntax. Yes, the syntax used in Arduino is compatible with ESP32. This similarity saves us a lot of effort when dealing with the ESP32.

Next, let's move on to creating our classic LED chaser.

## 2. LED Chaser Creation

## 1. Component List

-   ESP32 Development Board
-   Four LEDs (I used four 5mm red LEDs)
-   Four 220-ohm Resistors
-   Breadboard
-   Several Jumper Wires

## 2. Circuit Connection

![[LED4.png]]

## 3. LED Chaser Code

```arduino
/*******************************************************
   ESP32 LED Chaser
   Function: Sequentially light up four LEDs
   Pins: D15, D4, D2, D5
*******************************************************/

char LEDPins[] = {15, 4, 2, 5}; // Set the connected pins
int i = 0;
int L1 = 0;
int len = 0;

void setup() {
  len = sizeof(LEDPins) / sizeof(char); // Calculate array length
  for (i = 0; i < len; i++) {
    pinMode(LEDPins[i], OUTPUT); // Set pins as output
    digitalWrite(LEDPins[i], LOW); // Turn off LEDs
  }
}

void loop() {
  digitalWrite(LEDPins[L1], HIGH); // Turn on the current LED
  delay(100); // Wait for a short period
  digitalWrite(LEDPins[L1], LOW); // Turn off the current LED
  delay(100); // Wait for a short period
  L1 = L1 + 1; // Move to the next LED
  if (L1 > len || L1 < 0) // Check if reached the last or first LED
    L1 = 0; // Start from the beginning
}
```

By changing the number of GPIO","This article explains how to blink an LED using the ESP32 development board. It includes a component list, circuit diagram, and Arduino code for blinking the LED and creating an LED chaser project for beginners.",LED1.png,2024-11-25 12:45:52.996877,2025-07-28 01:34:58.146914,1367,0,1,2,how-to-blink-a-led-with-esp32,e216d8259b10791e6a1ed548433995f1
11,ESP32 Touch Button,"In this article we will talk about how to create a touch-sensitive button with ESP32's internal capacitive touch sensors:

![[touch_button1.png]]

ESP32 touch buttons can be used to control a variety of devices, such as LEDs, motors, and speakers. They can also be used to create user interfaces, such as menus and forms.

ESP32 features 10 internal capacitive touch sensors that can be utilized to create touch-sensitive buttons. The following are the GPIO pins corresponding to these sensors:

- T0: GPIO 4
- T1: GPIO 0
- T2: GPIO 2
- T3: GPIO 15
- T4: GPIO 13
- T5: GPIO 12
- T6: GPIO 14
- T7: GPIO 27
- T8: GPIO 33
- T9: GPIO 32

Arduino also provides corresponding syntax: `_touchRead(Touch Pin *);_`

For instance, to read the touch sensor 0 (T0), you can perform: `int value = touchRead(4);`

The values read here are analog, and you can use the Serial Monitor to check the sensor readings and adjust the code accordingly. Here is the corresponding code:

```arudio
/*******************************************************
   ESP32 Touch Button
   Function: Change LED state with a single touch on a touch button
   Pin: T0 (GPIO4)
   T0: GPIO 4
   T2: GPIO 2
   T3: GPIO 15
   T4: GPIO 13
   T5: GPIO 12
   T6: GPIO 14
   T7: GPIO 27
   T8: GPIO 33
   T9: GPIO 32
*******************************************************/

#define TOUTCH_PIN 4 // ESP32 Pin D4
#define LED_PIN 2

int touch_value = 100;
int flg = 0;

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println(""ESP32 Touch Test"");
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
}

void loop() {
  touch_value = touchRead(TOUTCH_PIN);
  Serial.println(touch_value);
  if (touch_value < 40) {
    flg = ~flg;
    digitalWrite(LED_PIN, flg);
  }
}
```

Here's the experimental result:

![[touch_button2.jpg]]

And just like that, a simple touch-sensitive button is complete.",This article discusses creating a touch-sensitive button using the ESP32's internal capacitive touch sensors. It details the GPIO pins associated with the sensors and explains how to read touch inputs using Arduino syntax.,touch_button2.jpg,2024-11-25 12:45:53.028902,2025-07-26 18:27:07.168314,1014,0,1,2,esp32-touch-button,d288544e5c4caaa787b19cac0b91cb57
12,Flash or Upload Configure File to ESP32,"Neko asked me how to flash IO pin configure to ESP32 on Youtube. In this article, I will introduce how to configure ESP32 by a file.

We can use ESP32 SPIFFS to store and read the configure file. SPIFFS (SPI Flash File System) allows you to use the flash memory of the ESP32 to store files, providing a way to read and write data in a structured manner similar to how files are managed on a traditional file system.

To save the ESP32 configuration file to a.txt file and be able to upload it to the ESP32, follow these steps:

1. Create a Configuration File.
2. Add code in ESP32 program to read the configuration file.
3. Include or upload the configuration file to the ESP32 by PlatformIO.

## Detailed Steps

### Step 1: Create the Configuration File

Create a file named `config.txt` and include the following content:

```txt
PIN_LED=2
PIN_BUTTON=4
```

### Step 2: Write ESP32 Code to Read the Configuration File
In your ESP32 code, add the code to read the configuration file and parse its content. For example:

```cpp
#include <Arduino.h>
#include <FS.h>
#include <SPIFFS.h>

int pinLED;
int pinButton;

void readConfigFile() {
    if(!SPIFFS.begin(true)){
        Serial.println(""An error has occurred while mounting SPIFFS"");
        return;
    }

    File file = SPIFFS.open(""/config.txt"", ""r"");
    if(!file){
        Serial.println(""Failed to open file for reading"");
        return;
    }

    while(file.available()){
        String line = file.readStringUntil('\n');
        int separatorIndex = line.indexOf('=');
        if (separatorIndex == -1) continue;

        String key = line.substring(0, separatorIndex);
        String value = line.substring(separatorIndex + 1);

        if (key == ""PIN_LED"") {
            pinLED = value.toInt();
        } else if (key == ""PIN_BUTTON"") {
            pinButton = value.toInt();
        }
    }
    file.close();
}

void setup() {
    Serial.begin(115200);

    readConfigFile();

    pinMode(pinLED, OUTPUT);
    pinMode(pinButton, INPUT);
}

void loop() {
    // Your main code here
}
```

In this example, it reads the content in `config.txt`, and splits each row string to pin define. You can change the code how to deal with the content as you need.

### Step 3: Upload the Configuration File 

Then we can upload/flash the configure file to ESP32 during PlatformIO flash code, or upload it at any time as needed.

In the root directory of your PlatformIO project, create a folder named `data` and place the `config.txt` file inside it.

![[fa89156459a2fa04d78407a258bfe04c_MD5.png]]

Add SPIFFS support in the `platformio.ini` file:

```ini
[env:esp32]
platform = espressif32
board = esp32dev
framework = arduino
monitor_speed = 115200
build_flags =
    -D CONFIG_SPIFFS_SIZE=1500000
```

Then flash code to ESP32 by the tools at the bottom toolbar. Or the side tools on the left panel.

![[524504fb9b76a7530663fc44d91a65a7_MD5.png]]

![[0399750bf425b99248a104a2e5155f0d_MD5.png]]

The first one `Upload` is upload compiled codes, the second one `Upload Filessystem Image` will upload files under the data folder to ESP32 SPIFFS.

Or use the following command to upload the SPIFFS file system:

```sh
pio run --target uploadfs
```","This blog explains how to flash or upload a configuration file to ESP32. It details the process using SPIFFS, including creating the file, writing ESP32 code to read it, and uploading it.",,2024-11-25 12:45:53.052013,2025-07-28 00:58:30.588845,964,0,1,2,flash-or-upload-configure-file-to-esp32,1ab33e36adf56019a933d6dc0c8a5dfc
13,Flash Code to ESP32 by Arduino IDE,"To flash an ESP32, it need to install the ESP32 board support package in the Arduino IDE.

Here are the steps to follow:

- Connect the ESP32 devolop board to your computer using the USB cable.
- Open the Arduino IDE and go to `File > Preferences`. In the `Additional Board Manager URLs` field, enter the URL for the ESP32 board support package

```
https://dl.espressif.com/dl/package_esp32_index.json
```

- Go to `Tools > Board > Boards Manager` and search for ""ESP32"". Install the ESP32 board support package.
- Go to `Tools > Board` and select the ESP32 board you are using (e.g. ""ESP32 Dev Module"").

![[Pasted image 20230104115007.png]]

- Select the port that the ESP32 is connected to. On above picture, it chooses `COM4`.
- Open the example sketch ""Blink"" by going to `File > Examples > 01. Basics > Blink`.
- Upload the code to the ESP32 by clicking the upload button (the right-facing arrow in the top left of the Arduino IDE).

If the upload is successful, the ESP32 should start blinking an LED (if it has one) at a 1-second interval.

!!! Bug

    For some kinds of ESP32 development board it's hardware design may not support auto download, while start flashing, it need pressing the ESP32's reset button before uploading the sketch.

    If you are not sure which development board has such feature, you can be the suggested board from [this link](https://www.amazon.com/dp/B0BRHTMZMF), this development board is able to auto download program to board.

If you have interesting about this ""bug"", can further read [[10_What_is_the_Secrete_Behind_ESP32_Auto_Flash]]",,Pasted image 20230104115007.png,2024-11-25 12:45:53.073408,2025-07-27 22:44:36.307923,1250,0,1,2,flash-code-to-esp32-by-arduino-ide,c95e7f892c993aa500c5f586ed087bf4
14,How to flash a bin file to ESP32,"## Method 1: Use the flash tool GUI application

1. Download and install the latest version of the ESP32 Flash Download Tool.
   https://www.espressif.com/en/support/download/other-tools
   ![[dcc6af2fc0d2cd846afe3665831ff994_MD5.png]]
1. Connect the ESP32 to your computer using a USB cable.
2. Open the ESP32 Flash Download Tool and select the ""ESP32 Download Tool"" option.
3. Click the ""Choose"" button and navigate to the bin file you want to flash to the ESP32.
4. Select the bin file and click ""Open.""
5. In the ""Flash Download Tool"" window, select the ""ESP32"" option in the ""Board"" dropdown menu.
6. In the ""Address"" field, enter the starting address where the bin file will be written to the ESP32. This is usually 0x0000.
   
7. Click the ""Download"" button to begin flashing the bin file to the ESP32.
8. Wait for the flashing process to complete, and then disconnect the ESP32 from the computer.
9. Your ESP32 should now be running the new firmware from the bin file.

Wait for the flashing process to complete. This may take a few minutes.

Once the flashing is complete, you should see a ""Success"" message in the Flash Download Tool.

You can now disconnect your ESP32 from your computer and use it with the new firmware. Keep in mind that flashing the firmware will erase any existing data on the ESP32, so make sure to backup any important data before proceeding.

or you can flash it with command

## Method 2: Use the flash python file

1. Download the latest version of esptool.py from the official GitHub page ([https://github.com/espressif/esptool](https://github.com/espressif/esptool))
2. Or install with python pip
```
pip install esptool
```

3. Connect your ESP32 board to your computer using a micro USB cable
4. Open a command prompt or terminal window and navigate to the directory where you saved the esptool.py file
5. Run the following command to flash the bin file to the ESP32:

```
esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 115200 write\_flash -z 0x1000 <path to bin file>
```


    !!! Note

        Replace `/dev/ttyUSB0` with the correct port for your ESP32 board and `<path to bin file>` with the actual path to the bin file on your computer.

5. Wait for the process to complete and the ESP32 to reboot. You should now be able to access the firmware on your ESP32.",,,2024-11-25 12:45:53.093868,2025-07-27 20:15:16.594606,3748,0,1,2,how-to-flash-a-bin-file-to-esp32,2f74f7d24db4492c3f66fc1c749f3585
15,What is the Secrete Behind ESP32 Auto Flash?,"Are you wondering why some of ESP32 development boards are able to auto flash but some of them are not?

And if we'd like to design an ESP32 product, how to make it support auto flash?

In this article, we will explain what happened there, and how to make it work.

## How does ESP32 goes into download boot mode?

First, let's check how ESP32 goes into different model at the start time.

- If reset pin (CHIP_PU) signal level to low for more than 50us, chip will rest.
- After chip reset, it will check the status of GPIO0 and GPIO2, then make a decision to go into which Boot Mode.

| Pin   | Default   | SPI Boot | Download Boot |
| ----- | --------- | -------- | ------------- |
| GPIO0 | Pull-up   | 1        | 0             |
| GPIO2 | Pull-down | X        | 0             |

The time sequence looks like this:

![[reset_time.png]]

Does it look complex? But in operation it's simple:

Hold the GPIO0 pin, then press and release the RESET pin.

On some board or schematic:

- The Reset pin is named as `EN` or `nRST`.
- The GPIO0 is named `BOOT`.

That process is to make GPIO0 LOW, after chip reset, then it will go into `Download Boot Mode`.

!!! Note

    From the above explain, it need pay attention if we design a EPS32 board by ourselves.
    
    - DO NOT pull down GPIO0.
    - DO NOT pull up GPIO2.

If you pull down GPIO0 on the circuit, then the chip will always try to go into download mode after reset.

If you pull down the GPIO2 on the circuit, then the chip will not be able to go into download mode.

## Pin Default Status

While measured on the board, if provide power to the dev board, the default status of `EN` and` BOOT` is `HIGH`. If the `EN` or `BOOT` button pressed, this pin will become to `LOW`.

|                | EN  | BOOT |
| -------------- | --- | ---- |
| Default        | 1   | 1    |
| Button Pressed | 0   | 0    |

## What happens during software start download?

The ESP32 Firmware Download Tools like `esptool.py` by ESP officials will initiate two signals that are named as `DTR` and `RTS`. It will help us to do auto trig ESP32 to boot download mode, by transferring these commands to USB chips, to change the status of ESP32 `RST` and `GPIO0` voltage level.

![ESP32 download circuit](https://esp32cube.com/usr/uploads/images/Snipaste_2022-12-16_14-27-19.png)

The according relationship between these signals is

| DTR | RTS | EN  | IO0 |
| --- | --- | --- | --- |
| 1   | 1   | 1   | 1   |
| 0   | 0   | 1   | 1   |
| 1   | 0   | 0   | 1   |
| 0   | 1   | 1   | 0   |

Notice that `EN` and `IO0` are pulled up internally, so the default or floating status of them are `HIGH`.

## Signal During Flash Code

Below picture shows the `EN` and `BOOT` during flash code to the dev board. 

- Yellow line: EN
- Green line: BOOT

At the left the IDE send command to dev board, trig the board reset, and go to download code mode, after code download, the dev board will auto reset again.
The yellow line, EN signal goes to low, will make let the dev board reset.

![[scope_5.png]]

Then let zoom in the left line, see what happen during that time.

![[scope_4.png]]

Let summary it step by step:

- EN goes down then rise up, ~71ms.
- EN goes down for a time, ~102.5ms.
- BOOT goes down, En rise up, ~55ms.

Per my understanding

- First step, trig the board to rest
- Step two, is rest stage, EN signal keeps LOW for 102.5ms.
- Step three, rest completed, board will detect BOOT (GPIO0) signal level to make decision. Yes, something let the GPIO0 to LOW, just at the board complete rest. GPIO0 is low, the board will goes to ""Download Boot"" mode.

**So this dev board, is able to auto flash code.**

If you want to have a board with such feature, please order it by this link:

[https://www.amazon.com/dp/B0BRHTMZMF](https://www.amazon.com/dp/B0BRHTMZMF)

Seems, it doesn't matter with the GPIO2? No, GPIO2 will impact it. If connected GPIO2 with 3V3 on the board, it will not able to download code also.

![[8cc7da2b91bb6a17e09080c50cb5c69.jpg]]

So, if you design a product with ESP32 please **do not pull up GPIO2**.

## NOT able to Auto flash board

Let's see another board that not able to auto flash code.

The IDE try to upload code to the board, but it tries to connecting the board like this:

```
Serial port COM4
Connecting........_____....._____....._____....._____....._____....._____....._____

A fatal error occurred: Failed to connect to ESP32: Timed out waiting for packet header
*** [upload] Error 2
==================================================== [FAILED] Took 33.61 seconds ====================================================
```

The signal level like this:
![[scope_6.png]]
Seem something repeatedly happen, let's zoom in to one pattern:

![[scope_7.png]]

EN low, then BOOT low, one time short, one time long.
So do you know why it can't go into ""Download Boot"" mode",,,2024-11-25 12:45:53.110226,2025-07-28 01:44:05.374194,804,0,1,2,what-is-the-secrete-behind-esp32-auto-flash,172da30c9ad43e0a6be5242438052305
16,ESP32 Dual-Core Usage,"In the world of microcontrollers, the ESP32 has gained substantial popularity for its advanced features and capabilities. One distinctive aspect that sets the ESP32 apart from other single-board microcontrollers is its support for dual-core processing. In this blog post, we will delve into the realm of ESP32's dual-core architecture, exploring how to harness its power through Arduino and optimizing code design for multi-core execution.

## 1. Introduction

The ESP32, an upgraded and enhanced version of the ESP8266, has made its mark as a faster and more feature-rich alternative. One of its standout features that sets it apart is its support for dual-core processing. Unlike its predecessor, the ESP32 allows developers to leverage the power of two processing cores for enhanced performance and multitasking capabilities. In this blog post, we will explore how to configure the ESP32's dual-core setup using the Arduino platform.

## 2. Hardware

Before we dive into the intricacies of code design, let's take a moment to discuss the hardware that makes this exploration possible. All you need is an ESP32 development board, readily available and equipped to handle the challenges of multi-core programming.

## 3. Code Design

Now, let's delve into the heart of the matter - designing code that takes full advantage of the ESP32's dual-core capabilities. For this demonstration, we will build upon the concepts introduced in the Queue tutorial to create a practical example. In this scenario, we will create two tasks: ""sendTask"" and ""receiveTask."" The ""sendTask"" will be pinned to Core 0, while ""receiveTask"" will reside on Core 1. The objective is to send data between these tasks using a Queue.

The key to achieving this lies in the `xTaskCreatePinnedToCore` API function. By utilizing this function, we can specify which core a particular task should run on. Additionally, the `xTaskGetAffinity` API function allows us to determine the core affinity of a task, providing insights into task distribution across the dual-core setup.

Here is a snippet of the code demonstrating the task creation and data exchange process:

```arudino
typedef struct {
    int sender;
    char *msg;
} Data;

xQueueHandle xQueue;
TaskHandle_t xTask1;
TaskHandle_t xTask2;

void setup() {
    Serial.begin(112500);
    xQueue = xQueueCreate(5, sizeof(Data));

    xTaskCreatePinnedToCore(sendTask, ""sendTask"", 10000, NULL, 1, &xTask1, 0);
    xTaskCreatePinnedToCore(receiveTask, ""receiveTask"", 10000, NULL, 1, &xTask2, 1);
}

void loop() {
    // Placeholder, as loop execution is not utilized in this example
}

void sendTask(void *parameter) {
    // Task logic for sending data
}

void receiveTask(void *parameter) {
    // Task logic for receiving and processing data
}

```

## 4. Results

The efforts put into configuring and optimizing the ESP32's dual-core usage culminate in tangible results. By effectively distributing tasks across the two cores and utilizing communication mechanisms like Queues, you can achieve efficient multitasking and enhanced performance in your projects.

![ESP32 Dual-Core](https://static.qutaojiao.com/wp-content/uploads/2018/10/35b6958b4e60d98.png)

In this illustration, we see the interplay between the dual-core setup and the tasks assigned to each core. This arrangement allows for seamless data exchange and parallel processing, unlocking the full potential of the ESP32's dual-core architecture.

In conclusion, the ESP32's support for dual-core processing offers an exciting avenue for optimizing performance and multitasking in your projects. By understanding the principles behind task distribution, affinity, and efficient communication, you can harness the power of the ESP32's dual-core capabilities to create more sophisticated and responsive applications.","The ESP32's dual-core architecture enhances performance and multitasking capabilities. In this blog post, we will explore how to configure the ESP32's dual-core setup using the Arduino platform.",,2024-11-25 12:45:53.127153,2025-07-27 23:51:32.311163,1020,0,1,2,esp32-dual-core-usage,1b175be89e7650dac568246e64221343
17,Develop ESP32 in VScode with PlatformIO,"With the aid of VScode and PlatformIO we can create and edit ESP32 projects to improve the efficiency quite a lot. It includes:

- Code highlight.
- Find the reference function with right click on it.
- Build code time is much shorter then Arduino IDE.
- Build and flash the code to the ESP32 development board.
- Debug the code by plotting the output of the serial port.

And PlatformIO supports developing ESP32 with Arduino platform or native ESP32 platform.

To develop an ESP32 project using PlatformIO and Visual Studio Code (VS Code), you will need to install both PlatformIO and VS Code on your computer.

![1671544888249](1671544888249.png)

## Install VS Code:

Download and install VS Code from the official website: https://code.visualstudio.com/

## Install PlatformIO:

- Open VS Code and click on the ""Extensions"" icon in the sidebar on the left.
- In the search bar, type ""PlatformIO"" and press Enter.
- Click on the ""Install"" button to install the PlatformIO extension.
- Once the installation is complete, you may be prompted to reload VS Code. Click on the ""Reload"" button to apply the changes.

You should now see the PlatformIO icon in the sidebar on the left. You can use this icon to access the PlatformIO Home screen, where you can create new projects, build and upload code, and access other PlatformIO features.

## Create a project

To create a new PlatformIO project for the ESP32.

- Open VS Code and click on the PlatformIO icon in the sidebar on the left.
- On the opened panel, click **Open**. It will open the PlatformIO main windows as below.

  ![1672116208773](1672116208773.png)
- Click the ""**New Project**"" button in the PlatformIO Home screen.

It will open a Project Wizard window shows as below

![1672115312485](1672115312485.png)

- In the field **Name**, set the name of the project as you like.
- **Board** select ""**DOIT ESP32 DEVKIT V1**"" from the dropdown lists.
- **Framework** select ""**Arduino**""
- Click on the ""**Finish**"" button to create the project.

It will need some times to dowload related file from internet. Depenends on your network condition, usually 1~2 minutes.

## Develop the code

In the VS Code Explorer, you will see the directory structure of your PlatformIO project.

The main source code file is located in the `src` directory and is named `main.cpp` by default.

You can edit this file and add your code to it.

## Build and upload code to ESP32

To build your code, click on the PlatformIO icon in the bottom toolbar and then click on the `Build` button.

To upload your code to the ESP32, click on the `Upload` button.

For more information on using PlatformIO with VS Code, you can refer to the PlatformIO documentation at https://docs.platformio.org/.

<div class=""video-wrapper"">
<iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/hDr9EEE94UM"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
</div>",,,2024-11-25 12:45:53.144707,2025-07-28 00:49:18.078217,833,0,1,2,develop-esp32-in-vscode-with-platformio,f91e9cb245685a04474864483e292030
18,How to use millis() instead of delay(),"In order to make a pause or wait for the task in Arduino, the most widely used function is `delay()`, but sometimes it was cause some problem, in this article it will discuss it, and shows how to use function `millis()` to replace it.

## Example code

For example, we'd like the board to flash the LED **precisely every 0.5 second**.

It will be very easy to write the code with delay function:

```Arduino
int ledPin=2;

void setup() {
    Serial.begin(115200);
    pinMode(ledPin, OUTPUT);
}
 
void loop() {
	digitalWrite(ledPin, HIGH); // Turn the LED on
	delay(500); // Wait for 0.5 seconds 
	digitalWrite(ledPin, LOW); // Turn the LED off 
	delay(500); // Wait for another 0.5 seconds
}
```

Now, if we insert some codes, let the board send some unused message to the serial port.

```Arduino
int ledPin=2;

void setup() {
    Serial.begin(115200);
    pinMode(ledPin, OUTPUT);
}
 
void loop() {
	digitalWrite(ledPin, HIGH); // Turn the LED on
	Serial.println(""LED is ON"");	
	Serial.println(""LED is ON"");
	Serial.println(""LED is ON"");
	delay(500); // Wait for 0.5 seconds 
	digitalWrite(ledPin, LOW); // Turn the LED off 
	Serial.println(""LED is OFF"");	
	Serial.println(""LED is OFF"");
	Serial.println(""LED is OFF"");
	delay(500); // Wait for another 0.5 seconds
}
```

You will find the LED flash time is more than 0.5 seconds. That is because it needs some time to execute the Serial.println() function. But we don't know how long it will take.

Then, we will use `millis()` function to implement it:

```Arduino
int ledPin = 2; 
unsigned long previousMillis = 0; // Store the time of the last LED toggle

void setup() {
  pinMode(ledPin, OUTPUT); // Set the LED pin as an output
}

void loop() {
  unsigned long currentMillis = millis(); // Get the current time
  if (currentMillis - previousMillis < 500) {    
    digitalWrite(ledPin, HIGH);
    Serial.println(""LED is ON"");
    Serial.println(""LED is ON"");
    Serial.println(""LED is ON"");
  } else if (currentMillis - previousMillis < 1000) {
    digitalWrite(ledPin, LOW);
    Serial.println(""LED is OFF"");
    Serial.println(""LED is OFF"");
    Serial.println(""LED is OFF"");
} else{
    previousMillis = currentMillis;
}
}

```

In above code, it will compare current CPU time to saved previousMillis to get the delta time. While the delta time:

- 0~0.5S, turn on the LED
- 0.5~1S, turn off the LED
- At time >= 1S, it will reset the previousMillis.

## Different between delay() and millis()

- `delay()` Specifies program pauses a number of milliseconds.
- `millis()` On the other hand, it returns the number of milliseconds elapsed since the program started.

So we know that `delay()` is a relative time clock. While `millis()` is an absolute time clock. And the most important things that delay() will pause the execution of other codes.

There are two main advantage to use millis other than delay:

### Get the exact time

The first advantage we will discuss is **accurate timing**. With `millis()`us, we can ensure that the loop executes as many times as needed, regardless of the execution time. With `delay()`this it's impossible because we don't know how long one loop takes to execute.

Such precise timing is useful when sampling or running filters at a certain frequency.

### No blocking

Another benefit `millis()`is that it doesn't prevent us from running code while ""waiting"".

`delay()` would pause the entire code until the time is reached.

## micros() and overflow

Just like `delay()`there is a microsecond version called `delayMicroseconds()`, `millis()` has `micros()`. If you need better resolution, you can use `micros()`.

But, be aware that `micros()` will overflow about every **70 minutes**, and `millis()` about **50 days**. This means that the function's return value will start at zero again.

## Summary

`millis()` and `micros()` is a very convenient function, which can be used when processing timed tasks. If you don't know these things, you'll probably end up just using them `delay()`, which may also works well.",,,2024-11-25 12:45:53.160872,2025-07-28 00:57:19.282172,2702,0,1,2,how-to-use-millis-instead-of-delay,5e638b0d4b2525054f9e41aee20bbe43
19,ESP32 Serial Output JSON data with ArduinoJson,"To output data from an ESP32 using serial communication, you can use the ArduinoJson library to encode the data into a JSON string. The following is an example code to output an integer value from the ESP32 over serial communication:

``` arduino
#include <ArduinoJson.h>

void setup() {
  Serial.begin(115200);
  delay(1000);
}

void loop() {
  // Create a JSON object
  StaticJsonDocument<200> doc;
  doc[""value""] = 123;

  // Serialize the JSON object
  String output;
  serializeJson(doc, output);

  // Send the serialized data over the serial port
  Serial.println(output);

  // Wait for a short period before sending the next data
  delay(1000);
}

```

In below example, it will output time, multiple temperature values, and pressure values from ESP32.

``` arduino
#include <ArduinoJson.h>

void setup() {
  Serial.begin(115200);
  delay(1000);
}

void loop() {
  // Create a JSON object
  StaticJsonDocument<200> doc;
  doc[""time""] = millis();

  JsonArray temperatures = doc.createNestedArray(""temperatures"");
  temperatures.add(25.1);
  temperatures.add(26.2);
  temperatures.add(27.3);
  temperatures.add(28.4);

  doc[""pressure""] = 1013.25;

  // Serialize the JSON object
  String output;
  serializeJson(doc, output);

  // Send the serialized data over the serial port
  Serial.println(output);

  // Wait for a short period before sending the next data
  delay(1000);
}
```


In this updated code, an array of temperatures is added to the JSON object using the createNestedArray function. The add function is then used to add the individual temperature values to the array. The rest of the code remains the same, with the JSON object being serialized and sent over the serial port as a string representation. The output data would now look like the following:

```
{""time"":123456,""temperatures"":[25.1,26.2,27.3,28.4],""pressure"":1013.25}
```",,,2024-11-25 12:45:53.180673,2025-07-27 21:38:02.304756,1410,0,1,2,esp32-serial-output-json-data-with-arduinojson,3a9d1a8887e604a45ea800e722ea92c3
20,ESP32 communicate with I2C devices,"## Hardware connection

On the ESP32 microcontroller, there are several pairs of GPIO pins that can be used for I2C communication. The default I2C pins on the ESP32 are GPIO 21 (SDA) and GPIO 22 (SCL), but other pairs of pins can also be used as long as they are correctly configured.

Here is a list of some of the GPIO pins that can be used for I2C communication on the ESP32:

* GPIO 21 (SDA) and GPIO 22 (SCL): default I2C pins
* GPIO 16 (SDA) and GPIO 17 (SCL): alternative I2C pins
* GPIO 18 (SDA) and GPIO 19 (SCL): alternative I2C pins

To use a different pair of pins for I2C communication, you will need to pass the pin numbers as arguments to the `Wire.begin()` function. For example, to use GPIO 16 and 17 as the I2C pins, you can call `Wire.begin(16, 17)`.

It's important to note that not all GPIO pins on the ESP32 are suitable for use as I2C pins. Some of the pins are reserved for other purposes, such as serial communication, and cannot be used as I2C pins. Consult the documentation of the ESP32 and the board you are using to make sure you are using the correct pins.

## ESP32 I2C communication code

To use the I2C communication protocol with the ESP32 microcontroller, you will need to use the I2C functions provided by the Arduino Core. Here is an example of how to use the I2C functions to read data from a device:

1. First, include the necessary libraries at the beginning of your sketch:

```
#include <Wire.h>
```

2. Initialize the I2C communication by calling the `Wire.begin()` function in the `setup()` function of your sketch. You may need to pass the I2C pins (SDA and SCL) as arguments if they are not the default ones.
3. To read data from a device, you will need to send a request to the device to read a specific number of bytes. To do this, you can use the `Wire.requestFrom()` function. This function takes two arguments: the address of the device and the number of bytes to read. You can find the address of the device in the documentation of the device or by using the `scanI2CBus()` function.
4. After sending the request, you can read the data from the device using the `Wire.read()` function. This function reads one byte of data from the device and returns it as an integer. You can read multiple bytes by calling the `Wire.read()` function multiple times.
5. If the device is not responding or if there was an error in the communication, you can check the return value of the `Wire.requestFrom()` function to see if the read was successful.

Here is an example of how to use the I2C functions to read two bytes of data from a device with the address 0x68:

```
#include <Wire.h>

void setup() {
  Wire.begin(); // initialize I2C communication
}

void loop() {
  Wire.requestFrom(0x68, 2); // request 2 bytes from device with address 0x68
  if (Wire.available()) { // check if the device responded
    int data1 = Wire.read(); // read first byte
    int data2 = Wire.read(); // read second byte
    // do something with the data
  }
}
```

If you are not sure about the device's I2C address, please ref to [ESP32/Arduino Scan Device I2C Address][1] to scanning the I2C devices connected to ESP32.


  [1]: https://esp32cube.com/post/ESP32-scan-device-I2C-address/",,,2024-11-25 12:45:53.207014,2025-07-28 01:39:39.288345,1576,0,1,2,esp32-communicate-with-i2c-devices,9f5afb0830978898768eb8dfb5dd87af
21,ESP32 SPI Communication,"## Hardware protal

The ESP32 microcontroller has two hardware SPI (Serial Peripheral Interface) controllers, which means it can communicate with up to two SPI devices simultaneously. Each SPI controller has its own set of pins, so you can use one controller for one device and the other controller for a different device, or you can use both controllers with the same device if necessary.

Here is a list of the pins used for each of the two SPI controllers on the ESP32:

SPI controller 0:

* MISO (Master In, Slave Out): GPIO 12
* MOSI (Master Out, Slave In): GPIO 13
* SCLK (Serial Clock): GPIO 14
* SS (Slave Select): GPIO 15

SPI controller 1:

* MISO (Master In, Slave Out): GPIO 2
* MOSI (Master Out, Slave In): GPIO 4
* SCLK (Serial Clock): GPIO 18
* SS (Slave Select): GPIO 5

To use the SPI controller in your sketch, you will need to include the `SPI.h` library and call the `SPI.begin()` function to initialize the controller. You can then use the `SPI.transfer()` function to send and receive data from the device.

### MISO and MOSI pin

you can use any GPIO pin on the ESP32 microcontroller as the MOSI (Master Out, Slave In) or MISO (Master In, Slave Out) pin for the SPI controller. The MOSI pin is used to send data from the master (the ESP32) to the slave device, while the MISO pin is used to send data from the slave device to the master.

To use a different pin as the MOSI or MISO pin for the SPI controller, you will need to pass the pin numbers as arguments to the `SPI.beginTransaction()` function. For example, to use GPIO 16 as the MOSI pin and GPIO 17 as the MISO pin for the SPI controller, you can call `SPI.beginTransaction(SPISettings(8000000, MSBFIRST, SPI_MODE0, 16, 17))`.

It's important to note that not all GPIO pins on the ESP32 are suitable for use as an MOSI or MISO pin. Some of the pins are reserved for other purposes, such as serial communication, and cannot be used as an MOSI or MISO pin. Consult the documentation of the ESP32 and the board you are using to make sure you are using the correct pins.

Here is a list of the pins that cannot be used as the MISO pin on the ESP32:

* GPIO 0: used as the bootstrap pin
* GPIO 2: used as the UART0 RX pin
* GPIO 3: used as the UART0 TX pin
* GPIO 4: used as the UART1 RX pin
* GPIO 5: used as the UART1 TX pin
* GPIO 9: used as the UART2 RX pin
* GPIO 10: used as the UART2 TX pin
* GPIO 16: used as the UART3 RX pin
* GPIO 17: used as the UART3 TX pin
* GPIO 18: used as the SCLK pin for the second SPI controller
* GPIO 19: used as the MOSI pin for the second SPI controller

you can use any GPIO pin on the ESP32 microcontroller as the SS (Slave Select) pin for the SPI controller. The SS pin is used to select the slave device that the master (the ESP32) wants to communicate with. By using a different pin as the SS pin for each slave device, you can use the same MISO, MOSI, and SCLK pins to communicate with multiple slave devices.


### Devices Select pin, SS

To use a different pin as the SS pin for the SPI controller, you will need to pass the pin number as an argument to the `SPI.begin()` function. For example, to use GPIO 16 as the SS pin for the SPI controller, you can call `SPI.begin(16)`.

It's important to note that not all GPIO pins on the ESP32 are suitable for use as an SS pin. Some of the pins are reserved for other purposes, such as serial communication, and cannot be used as an SS pin. Consult the documentation of the ESP32 and the board you are using to make sure you are using the correct pins.

## ESP32 SPI Code

Here is an example of how to use the SPI communication protocol with the ESP32 microcontroller to send and receive data from a slave device:

1. Include the necessary libraries at the beginning of your sketch:

```
#include <SPI.h>
```

2. Initialize the SPI communication by calling the `SPI.begin()` function in the `setup()` function of your sketch. You can pass the SS (Slave Select) pin as an argument if you are using a different pin than the default one.
3. To send and receive data from the slave device, you will need to select the device by setting the SS pin low and then calling the `SPI.transfer()` function to send and receive data. The `SPI.transfer()` function takes one argument, which is the data to be sent to the slave device, and returns the data received from the slave device as a byte.
4. After you have finished communicating with the slave device, you should set the SS pin high to deselect the device.

Here is an example of how to send a byte of data to a slave device and read the response using the SPI communication:

```
#include <SPI.h>

const int ssPin = 15; // SS pin for the slave device

void setup() {
  SPI.begin(); // initialize SPI communication
}

void loop() {
  digitalWrite(ssPin, LOW); // select the slave device
  byte response = SPI.transfer(0x01); // send data to the slave device and read the response
  digitalWrite(ssPin, HIGH); // deselect the slave device

  // do something with the response
}

```",,,2024-11-25 12:45:53.235399,2025-07-28 01:01:35.645535,1447,1,1,2,esp32-spi-communication,8e60d7e7007978d5d0c070fb231d9932
22,ESP32/Arduino Scan Device I2C Address,"# ESP32/Arduino finds the address of I2C device

When uses I2C devices, it often needs to check whether the I2C device communicates rightly, or the device's I2C address is set wrong.

This code will scan the I2C bus from address 1 to address 127 and will print out the address of any devices that respond.

``` Arduino
#include <Wire.h>

void setup() {
  Wire.begin();
  Serial.begin(115200);
  Serial.println(""I2C device scanner."");
}

void loop() {
  byte error, address;
  int nDevices;

  Serial.println(""Scanning..."");

  nDevices = 0;
  for(address = 1; address < 127; address++ )
  {
    // The i2c_scanner uses the return value of
    // the Write.endTransmisstion to see if
    // a device did acknowledge to the address.
    Wire.beginTransmission(address);
    error = Wire.endTransmission();

    if (error == 0)
    {
      Serial.print(""I2C device found at address 0x"");
      if (address<16)
        Serial.print(""0"");
      Serial.print(address,HEX);
      Serial.println(""  !"");

      nDevices++;
    }
    else if (error==4)
    {
      Serial.print(""Unknow error at address 0x"");
      if (address<16)
        Serial.print(""0"");
      Serial.println(address,HEX);
    }    
  }
  if (nDevices == 0)
    Serial.println(""No I2C devices found\n"");
  else
    Serial.println(""done\n"");

  delay(5000);           // wait 5 seconds for next scan
}
```",,,2024-11-25 12:45:53.260821,2025-07-28 00:21:06.167087,704,0,1,2,esp32arduino-scan-device-i2c-address,6c94ecaa89d366956b545381fa9a2651
23,How to Connect ESP32 to Wi-Fi?,"There are serval ways to connect ESP32 to Wi-Fi, in this article we will intorduce it.

## Provide Wi-Fi ID and password in the code

This is the simplest way, but the disadvatage of this way is user not able to change the Wi-Fi to other routers. And this may just can be use for developer.

To connect an ESP32 to a Wi-Fi network, you will need to provide it with the credentials for the network. These credentials typically include the network name (SSID) and password. You can provide these credentials to the ESP32 through its firmware, which can be programmed using the Arduino IDE or another programming tool. Once the ESP32 has the credentials, it can use them to connect to the Wi-Fi network.

Here is an example of how to connect ESP32 to wifi:

``` Arduino
#include <WiFi.h>

const char* ssid = ""your_SSID"";
const char* password = ""your_PASSWORD"";

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println(""Connecting to WiFi..."");
  }
  Serial.println(""Connected to WiFi"");
}

void loop() {
  // put your main code here, to run repeatedly:
}
```

Make sure you have the WiFi.h library installed and SSID and PASSWORD is updated with your wifi details.

In this example, the ESP32 will attempt to connect to the Wi-Fi network with the specified SSID and password. It will enter into an infinite loop until the ESP32 successfully connects to the Wi-Fi network. Once the ESP32 is connected, it will print ""Connected to WiFi"" to the serial monitor.",,,2024-11-25 12:45:53.280506,2025-07-28 01:10:04.746319,608,0,1,2,how-to-connect-esp32-to-wi-fi,e2be4d290bb8196b9c913e0f81a5818c
24,ESP32 WiFi Configuration Tutorial,"## Introduction

The ESP32 is a powerful microcontroller that comes with built-in WiFi capabilities. With this feature, it is possible to connect the ESP32 to the internet and even use it to create a WiFi hotspot. In this tutorial, we will guide you through the process of configuring the WiFi module of the ESP32.

## WiFi Configuration Steps

1.  Include the WiFi library: To use the WiFi module, we need to include the WiFi library at the beginning of our code. This is done by adding the following line of code:

```
#include ""WiFi.h"";
```

1.  Set up the WiFi connection: Next, we need to set up the WiFi connection. This is done by creating a new instance of the WiFi class and using it to connect to the WiFi network. Here is an example of how to do this:

```
const char* ssid = ""your_SSID"";
const char* password = ""your_PASSWORD"";

WiFi.begin(ssid, password);
```

1.  Wait for WiFi connection: After starting the WiFi connection, we need to wait for the ESP32 to connect to the WiFi network. This is done by using the `WiFi.status()` function to check the status of the WiFi connection. Here is an example of how to do this:

```
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println(""Connecting to WiFi..."");
}
```

1.  Print the IP address: Once the ESP32 is connected to the WiFi network, we can print the IP address of the ESP32 to the Serial Monitor. This is done by using the `WiFi.localIP()` function. Here is an example of how to do this:

```
Serial.println(WiFi.localIP());
```

## Security Considerations

When configuring the WiFi module of the ESP32, it is important to consider security. Here are some best practices to keep in mind:

### Use a Strong Password

Always use a strong password for your WiFi network. A weak password can be easily cracked by hackers, leaving your ESP32 and other devices on your network vulnerable to attack.

### Do Not Hardcode Your WiFi Credentials

Never hardcode your WiFi credentials in your code. Hardcoding makes it easy for attackers to gain access to your network, as your credentials will be openly available in the code. Instead, consider using a separate configuration file or inputting them through the Serial Monitor.

### Use HTTPS

When making web requests with the ESP32, consider using HTTPS instead of HTTP. HTTPS encrypts the data transmitted between the ESP32 and the server, making it more difficult for attackers to intercept and read.

### Disable the WiFi Hotspot Feature

If you are not using the hotspot feature, it is best to disable it. The hotspot feature can be a security risk if not configured properly, as it can allow unauthorized access to your network.

## Conclusion

Configuring the WiFi module of the ESP32 is a straightforward process that can enable powerful internet-connected projects. By following the steps in this tutorial and keeping security considerations in mind, you can create robust and secure ESP32 projects with WiFi capabilities. Be sure to use a strong password, avoid hardcoding credentials, use HTTPS, and disable the hotspot feature when not in use. With these precautions in place, you can take full advantage of the ESP32's WiFi capabilities and build amazing projects that are both functional and secure.

## Power Consumption Considerations

When designing a project with the ESP32 and WiFi capabilities, it is important to consider power consumption. WiFi connectivity can be a significant drain on the ESP32's battery, so it is important to optimize your code and configuration to minimize power consumption.

One way to reduce power consumption is to use the `WiFi.disconnect()` function when the ESP32 is not actively using the WiFi network. This function will disconnect the ESP32 from the network, saving power. You can also use the `WiFi.mode(WIFI_OFF)` function to turn off the WiFi module entirely when it is not needed.

Another way to reduce power consumption is to increase the sleep time of the ESP32. The ESP32 can be put into deep sleep mode, which uses very little power. When the ESP32 is in deep sleep mode, it can still be woken up by an interrupt or timer, allowing it to perform its intended function.

## Troubleshooting WiFi Connectivity Issues

If you are having trouble connecting the ESP32 to your WiFi network, there are several steps you can take to troubleshoot the issue. Here are a few things to try:

### Double-check Your Credentials

Make sure that the SSID and password you are using to connect to your WiFi network are correct. A simple typo or mistake can prevent the ESP32 from connecting.

### Check Your WiFi Signal Strength

If the WiFi signal strength is weak, the ESP32 may have trouble connecting to the network. Try moving the ESP32 closer to the router or using a WiFi signal booster to improve the signal strength.

### Check Your Router Configuration

Make sure that your router is configured to allow the ESP32 to connect to the network. Some routers may have security settings or other configurations that prevent new devices from joining the network.

### Increase the Connection Timeout

If the ESP32 is having trouble connecting to the network, you can increase the connection timeout using the `WiFi.begin(ssid, password, timeout)` function. This will give the ESP32 more time to connect to the network before timing out.

## Conclusion

Configuring the WiFi module of the ESP32 is a powerful tool that enables many new possibilities for your projects. By following the steps in this tutorial, you can easily set up the WiFi connection of your ESP32 and take full advantage of its capabilities. Remember to keep security and power consumption considerations in mind, and troubleshoot any connectivity issues that arise. With these tips, you will be well on your way to building amazing projects with the ESP32's WiFi capabilities.",,,2024-11-25 12:45:53.313240,2025-07-27 23:34:01.390352,1216,0,1,2,esp32-wifi-configuration-tutorial,eae70d06b0d2cec66295570a7d61e982
25,ESP32 Get Sound from I2S Microphone,"ESP32 includes a built-in I2S audio peripheral, which can be used to interface with an external I2S microphone.

I2S (Inter-IC Sound) is a serial bus protocol used for transmitting audio data.

![[Pasted image 20230104131805.png]]

To use an I2S microphone with the ESP32, you will need to connect the microphone to the I2S interface on the ESP32 and configure the ESP32 to read audio data from the microphone. The exact connection and configuration will depend on the specific microphone you are using and the development platform you are using to program the ESP32.

Here is an example of how to set up an I2S microphone with the ESP32 using the Arduino development platform.

## Wire connection between I2S microphone model and ESP32

| Microphone | ESP32  |
| ---------- | ------ |
| SCK        | GPIO14 |
| SD         | GPIO32 |
| WS         | GPIO15 |
| L/R        | GND    |
| GND        | GND    |
| VDD        | 3.3V   |

## Example Code

``` c
#include ""driver/i2s.h""

void setup() {
  // Initialize serial console
  Serial.begin(115200);

  // Configure I2S microphone
  i2s_config_t i2s_config = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
    .sample_rate = 16000,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
    .channel_format = I2S_CHANNEL_FMT_ALL_RIGHT,
    .communication_format = I2S_COMM_FORMAT_I2S,
    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
    .dma_buf_count = 2,
    .dma_buf_len = 64
  };
  i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);
  i2s_set_pin(I2S_NUM_0, &i2s_pin_config);
  i2s_set_clk(I2S_NUM_0, 16000, I2S_BITS_PER_SAMPLE_16BIT, I2S_CHANNEL_MONO);
}

void loop() {
  // Allocate buffer to store audio data
  const int num_samples = 512;
  int16_t samples[num_samples];

  // Read audio data from I2S microphone
  size_t bytes_read = 0;
  i2s_read(I2S_NUM_0, samples, num_samples * sizeof(int16_t), &bytes_read, portMAX_DELAY);

  // Print audio data to serial console
  for (int i = 0; i < num_samples; i++) {
    Serial.println(samples[i]);
  }
}
```

This code sets up the ESP32 to read audio data from an I2S microphone at a sample rate of 16kHz with 16-bit samples. It then reads a block of audio data (512 samples) from the microphone and prints the data to the serial console.

Keep in mind that this is just a simple example to illustrate the basic steps involved in reading audio data from an I2S microphone with the ESP32. In a real application, you will likely want to do more with the audio data (e.g. perform FFT or filtering) and use the data to trigger events or actions.","This tutorial explains how to build an IoT application to control a light switch remotely using the ESP32 microcontroller, Wi-Fi, and a relay module.",,2024-11-25 12:45:53.337037,2025-07-28 01:25:25.295031,2351,0,1,2,esp32-get-sound-from-i2s-microphone,48d288fd14b79916e9e99ad9d154ecb3
26,ESP32 read PT1000/PT100 temperature sensor values,"# ESP32 read PT1000/PT100 temperature sensor values

In this article, it will introduce how to read the temperature values from PT1000 with ESP32.

## The principle of PT1000 measure temperature

PT1000 sensors are temperature sensors that use the principle of resistance to measure temperature. These sensors have a resistor with a resistance that changes with temperature. The resistance of the PT1000 sensor increases as the temperature increases, and decreases as the temperature decreases.

## About the name

The name of the PT1000 temperature sensor, as below:

- **Pt** stands for Platinum, which is the material used in the sensor.
- **1000** represents the resistance at 0°C.

Thus, PT1000 indicates a platinum-based sensor with a resistance of 1000 ohms at 0°C. 

Similarly, PT100 and PT500 sensors have resistances of 100 and 500 ohms at 0°C, respectively.

Although this article is discussing the PT1000 temperature sensor, the principles of measurment can apply to other types of analog sensors as well. Because we are measuring the voltage across the ""resistor"", then converting this voltage to a resistance, and finally to a physical attribute (e.g. temperature).

I think that meathod is also applicable to other types of analog sensors measurement:

- If we understand the principles of PT1000 temperature sensor measurement, we can use it to measure any analog sensor. 
- And if we increase the accuracy of the PT1000 temperature sensor measurement, we can apply it to other types of analog sensors as well.

## Resistance values at different temperature

**IEC 60751** provides the coefficients for the Callendar-Van Dusen equation, which is used to calculate the resistance of platinum RTDs over a specified temperature range.
#### Callendar-Van Dusen Equation

For temperatures between -200°C and 0°C:

$$
R_t = R_0 (1 + A \cdot t + B \cdot t^2 + C \cdot (t - 100) \cdot t^3)
$$

For temperatures between 0°C and 850°C:

$$
R_t = R_0 (1 + A \cdot t + B \cdot t^2)
$$

Where:
- $R_t$ is the resistance at temperature $t$ (in °C).
- $R_0$ is the resistance at 0°C (e.g., 1000 ohms for PT1000).
- $A$, $B$, and $C$ are constants. $C$ is only used for temperatures below 0°C.

#### Coefficients for Platinum RTDs (according to IEC 60751):

- $A = 3.9083 \times 10^{-3} \, \Omega/(\Omega \cdot °C)$
- $B = -5.775 \times 10^{-7} \, \Omega/(\Omega \cdot °C^2)$
- $C = -4.183 \times 10^{-12} \, \Omega/(\Omega \cdot °C^4)$ 

Plot the temperature resistance relationship shows as below:

![[pt1000_resistance.svg]]

Note:

So if we can measure the resistance of the PT1000 sensor, the we can calculate the temperature using the equation.
    
But the main problem is how to **""precisely""** measure the resistance of the PT1000 sensor.

We will introduce different methods to measure the resistance of the PT1000 sensor. It will increase the accuracy step by step. By this series of methods, you can choose the most suitable one for your application. And these types of methods are also applicable to other types of analog sensors measurement.

- Measure resistance with ESP32 ADC. (this article)
- Increase accuracy with 3 wire connection.
- Increase accuracy with 4 wire connection.
- Increase accuracy with a Wheatstone bridge.
- Increase accuracy with an ADC with a higher resolution.

## Measure resistance with ESP32 ADC

Let's start from the most simple method, measure the resistance of the PT1000 sensor with ESP32 ADC.

The ADC (analog-to-digital converter) on the ESP32 can be used to measure the voltage on an analog input pin. The ADC can be configured to measure the voltage on the PT1000 sensor, and the resulting voltage can be used to calculate the resistance of the sensor.

## Hardware connection

To read PT1000 analog values and convert them to temperature with an ESP32, you can follow these steps:

Inorder to measure the PT1000 resistance values by ESP32 analog GPIO, we can connect the circuit as below:

1. Connect a precise 100Ω resistor (referred to as $ R_{\text{ref}} $) in series with the PT100 resistor.  
2. Connect one end of the circuit to the 5V output of the Arduino and the other end to ESP32 GND.  
3. Connect the midpoint between the two resistors to an ESP32 analog input (e.g., A0).

The words maybe to hard to understanding, ref to below picture about the connection.

![[pt1000_circuit2.jpg]]

![[pt1000_circuit.jpg]]


The voltage $V_{\text{out}}$ can be expressed as:

$$
V_{\text{out}} = 5V \times \frac{R_{\text{PT1000}}}{R_{\text{ref}} + R_{\text{PT1000}}}
$$

By measuring $ V_{\text{out}} $, we can calculate the resistance of the PT1000 $ R_{\text{PT1000}} $.

To calculate the resistance $ R_{\text{PT1000}} $ from the measured voltage $ V_{\text{out}} $, you can rearrange the voltage divider formula:

$$
R_{\text{PT1000}} = R_{\text{ref}} \times \frac{V_{\text{out}}}{5V - V_{\text{out}}}
$$

Here:

- $R_{\text{PT1000}}$ is the resistance of the PT1000 sensor at certain temperature (in ohms).
- $R_{\text{ref}}$ is the known reference resistor (e.g., 1000Ω).
- $V_{\text{out}}$ is the measured voltage at the midpoint between $ R_{\text{ref}} $ and $R_{\text{PT1000}}$.

Use the `analogRead()` function to read the analog value from the PT1000 sensor. This function returns a value between 0 and 4095, corresponding to the voltage on the analog input pin.

The sample code:

```c
#define PT1000_ANALOG_PIN 25   // Analog input pin for PT1000 sensor (GPIO25)
#define PT1000_R_REF 1000.0     // Reference resistance for PT1000 sensor at 0°C (in ohms)
#define V_SUPPLY 3.3            // Supply voltage to the voltage divider

// Lookup table for resistance-to-temperature conversion
float temperatureTable[] = {-40.0, -20.0, 0.0, 20.0, 40.0, 60.0, 80.0, 100.0, 120.0}; // Corresponding temperature values
float resistanceTable[] = {842.7, 921.6, 1000, 1077.9, 1155.4, 1232.4, 1309, 1385.1, 1460.7}; // Add more values as needed

// Linear interpolation function
float interpolate(float x, float xTable[], float yTable[], int size) {
  for (int i = 1; i < size; i++) {
    if (x <= xTable[i]) {
      // Linear interpolation
      float x0 = xTable[i - 1];
      float x1 = xTable[i];
      float y0 = yTable[i - 1];
      float y1 = yTable[i];
      return y0 + (y1 - y0) * (x - x0) / (x1 - x0);
    }
  }
  // Extrapolation if x is outside the range of the table
  return yTable[size - 1];
}

void setup() {
  Serial.begin(115200);  // Initialize serial communication
  pinMode(PT1000_ANALOG_PIN, INPUT);  // Set GPIO25 as input
}

void loop() {
  // Read analog value from PT1000 sensor
  int analogValue = analogRead(PT1000_ANALOG_PIN);

  // Convert analog value to voltage
  float vOut = analogValue * (V_SUPPLY / 4095.0);  // Adjust for ESP32 ADC resolution (12-bit)

  // Calculate PT1000 resistance
  float resistance = PT1000_R_REF * vOut / (V_SUPPLY - vOut);

  // Convert resistance to temperature using linear interpolation
  float temperature = interpolate(resistance, resistanceTable, temperatureTable, sizeof(resistanceTable) / sizeof(resistanceTable[0]));

  // Print temperature to serial monitor
  Serial.print(""Temperature: "");
  Serial.print(temperature);
  Serial.println(""°C"");

  // Wait for 1 second before taking another reading
  delay(1000);
}
```",,,2024-11-25 12:45:53.361907,2025-07-27 23:25:44.028699,5651,3,1,2,esp32-read-pt1000pt100-temperature-sensor-values,4a85e6ccccdb170e27683a58570b5628
27,How to Use ESP32 and WS2812B to Create Stunning LED Displays,"# How to Use ESP32 and WS2812B to Create Stunning LED Displays

Hey there! You know how when you're learning to work with hardware, the first thing you usually do is make an LED blink? It's a fun and simple way to get the basics down. But let's be real, blinking a single LED in one color gets old pretty quickly. So why not take it up a notch? Enter WS2812B LEDs!

![[34d57dfc36790bd38faaa1a3df9016d3_MD5.png]]

These little gems can light up in multiple colors and create amazing lighting effects. Ready to dive in? Let's do it!

## The Magic of WS2812B LEDs

WS2812B LEDs, also known as NeoPixels, are super cool because each one is individually addressable. This means you can control each LED separately to display any color you want. Here’s why they're awesome:

- **Individually Addressable**: Control each LED independently for stunning patterns and animations.
- **Rich Color Range**: With 16 million colors, the possibilities are endless.
- **Chainable**: Easily connect multiple LEDs in a series for expansive designs.
- **Simple Wiring**: Just three wires—power, ground, and data—make the setup straightforward.

## Controlling WS2812B LEDs with ESP32

The ESP32 is like the superhero of microcontrollers. It's got Wi-Fi, Bluetooth, and plenty of processing power, making it perfect for controlling WS2812B LEDs.

### What You Need:

- ESP32 Development Board
- WS2812B chip or LED Strip
- Power Supply (5V)
- Breadboard and Jumper Wires (optional for prototyping)
- Resistor (330 ohms)
- Capacitor (1000 µF, 6.3V or higher)

## Setting It All Up

Here's a simple wiring diagram to get you started with your ESP32 and WS2812B LED strip:

1. **Power Supply**: Connect the positive terminal of the power supply to the 5V pin on the WS2812B strip and the 5V pin on the ESP32. Connect the negative terminal of the power supply to the GND pin on both the WS2812B strip and the ESP32.
2. **Data Line**: Connect the data input pin (DIN) of the WS2812B strip to a digital output pin on the ESP32 (e.g., GPIO 13).


![[67c0a602f5f2d729a33c703ef3f0ec3c_MD5.png]]

## Install the FastLED Library

To control the WS2812B LEDs, we’ll use the FastLED library. First, you need to install the FastLED library in your PlatformIO project. You can do this by adding the following line to your `platformio.ini` file under the `lib_deps` section it will automatically download the library for you when you build the project.

```ini
lib_deps = 
    FastLED
```

Or you can search for FastLED in the PlatformIO library manager and install it from there.

![[2aa0faf421eb7fb043ec39a212c7fe36_MD5.png]]

## Example Code

Here’s an example to get you started:

```cpp
#include <FastLED.h>

#define LED_PIN     13
#define NUM_LEDS    5
#define BRIGHTNESS  64
#define LED_TYPE    WS2812B
#define COLOR_ORDER GRB
CRGB leds[NUM_LEDS];

void setup() {
    // Tell FastLED about the LED strip configuration
    FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection(TypicalLEDStrip);
    FastLED.setBrightness(BRIGHTNESS);
}

void loop() {
    // Fill the LED array with a rainbow pattern
    fill_rainbow(leds, NUM_LEDS, 0, 7);
    // Display the updated LED colors
    FastLED.show();
    // Pause for a moment before the next update
    delay(100);
}
```

This code sets up a strip of 30 WS2812B LEDs connected to GPIO 13 on the ESP32. It creates a rainbow effect that continuously updates every 100 milliseconds.

## Wrapping Up

With the ESP32 and WS2812B LEDs, the possibilities for creative lighting projects are virtually endless. From simple color patterns to intricate animations, these components offer a powerful yet accessible platform for DIY enthusiasts and professionals alike. So, grab your ESP32, fire up your Arduino IDE, and start bringing your LED projects to life!

Next time we will discuss how to design a PCB with WS2812B LEDs, then you can use one LED to indicate different states of your product. Stay tuned!

Got questions or want to share your projects? Drop a comment below. Happy tinkering!",,,2024-11-25 12:45:53.389546,2025-07-28 01:39:49.162109,4713,0,1,2,how-to-use-esp32-and-ws2812b-to-create-stunning-led-displays,acd07b5b6c866e0de489d27777036699
28,A LED Matrix Message Board with ESP32,"# A LED Matrix Message Board with ESP32

This project is an LED matrix message board based on the ESP32 microcontroller. It is capable of connecting to the network and displaying real-time news, weather, stock, date, time, and barometric pressure data. It also supports menu and web interfaces, as well as notification functions. The LED matrix modules display information in a set format on the screen, allowing users to conveniently access various types of information.

![[29694cf1941223b27283e339ec2f8351_MD5.webp]]

# Hardware List

- **ESP32 Development Board**
- **MAX7219 8x8 LED Matrix Modules (x16)**
- **Barometric Pressure Sensor Module - BME280 (x1)**
- **Rotary Encoder with Button (x1)**
- **Buzzer (x1)**

![[c0ec0452f6a5d1733c82b9ee7151de67_MD5.webp]]

# Construction Method

The LED matrix modules are connected in series to the ESP32, with a total of 16 MAX7219 8x8 LED matrix modules. To maintain a neat and compact setup, modules can be secured together using tape and cardboard.

![[04d1cf2d06a151fef543765ac20b782c_MD5.webp]]

Given the large number of LEDs (1024 in total), an external power supply is required to power the LED matrix, preferably one with 2A or higher power output. Additionally, the BME280 sensor and rotary encoder should be connected to the ESP32 according to the provided module schematic.

![[89b15aa81780df91c6b81583de6c616a_MD5.webp]]

# Features and Characteristics

The LED matrix message board has the following features and characteristics:

- **Time and Data Display**: It connects to local WiFi networks and time servers to obtain local date and time, and can also determine if daylight saving time is in effect, ensuring users always receive accurate time information.
- **Display Areas**: The message board has three display areas for time, alternating date and barometric pressure information, and the main information display, allowing users to quickly access different types of information at a glance.
- **Interactive Control**: Users can use a rotary encoder to select menu items, such as the main rotation, various news categories, or stock data, offering a user-friendly interaction method.
- **Web Interface**: The LED matrix message board can display custom messages and perform control operations through a web interface, including sending messages and triggering the buzzer to produce notification sounds.

![[cc66fab10c33e8c6552050cd8a0470a0_MD5.webp]]

# Software Code

The LED matrix message board requires the following open-source software libraries:

- [Adafruit BME280 Library](https://github.com/adafruit/Adafruit_BME280_Library)
- [ArduinoJson](https://github.com/bblanchon/ArduinoJson)
- [Dusk2Dawn](https://github.com/dmkishi/Dusk2Dawn)
- [MD_MAX72XX](https://github.com/MajicDesigns/MD_MAX72XX)
- [MD_Parola](https://github.com/MajicDesigns/MD_Parola)
- [RotaryEncoder](https://github.com/mathertel/RotaryEncoder)
- [Time](https://github.com/PaulStoffregen/Time)

![[707a5801ae6e839368ae41eb9f01c335_MD5.webp]]

# Summary

The LED matrix message board integrates hardware and software to display various real-time information and provides a user-friendly interaction method. With its multiple features and characteristics, it can help users access a variety of real-time information, making it a very practical device.

Project code can be found at: [Baidu Pan Link](https://pan.baidu.com/s/1TioSl3KmoTTEJI93zJ4GVQ?pwd=1234)",,,2024-11-25 12:45:53.414610,2025-07-28 01:34:16.764006,866,0,1,2,a-led-matrix-message-board-with-esp32,fe1d1eb50206f1f8bd4a2f4667179b59
29,ESP32 Sensor DHT11 Temperature and Humidity Sensor,"# DHT11 Temperature and Humidity Sensor

DHT11 can measure both temperature and humidity, it is a popular, cost-effective sensor. In this article we will discuss how to read temperature and humidity with ESP32 and DHT11.

![[aea7154f82a4235eb82421097f297927_MD5.jpg]]

## Hardware Required

- ESP32 development board
- DHT11 temperature and humidity sensor
- Jumper wires

## Wire Connection

- Connect V of DHT11 to the 3.3V or 5V pin on the ESP32.
- Connect G of DHT11 to one of the GND pins on the ESP32.
- Connect S pin of DHT11 to a GPIO pin on the ESP32 (e.g., GPIO 5).

The supply voltage for the DHT11 is 3~5.5V.
![[fa0f63c6db65330d1d3da64c96f08177_MD5.jpg]]

## Installing the DHT Library

We will use the DHT library to read temperature and humidity from the DHT11 sensor.

Search for DHT library in the PlatformIO Library Manager and install it.

![[a9d1d4e032ea9a1d3448904e16ed06d2_MD5.png]]

Library installation, click on the ""Add to Project"" button.

![[f6f0506e2756ee930071ad6f5c471eec_MD5.png]]

Then choose the project we defined earlier and click on the ""Add"" button.

![[d28d7f2afd97ef65ef676956ae8dc418_MD5.png]]

## Code

Here is the example code to read temperature and humidity from the DHT11 sensor and print it to the serial monitor.

```c++
#include <Arduino.h>
#include ""DHT.h""

#define DHTPIN 5     // GPIO pin the sensor is connected to
#define DHTTYPE DHT11   // DHT 11
DHT dht(DHTPIN, DHTTYPE);

void setup() {
  Serial.begin(115200);
  dht.begin();
}

void loop() {
  // Reading temperature and humidity
  float h = dht.readHumidity();
  float t = dht.readTemperature();

  // Check if any reads failed and exit early (to try again).
  if (isnan(h) || isnan(t)) {
    Serial.println(""Failed to read from DHT sensor!"");
    return;
  }

  // Print the results to the serial monitor
  Serial.print(""Humidity: "");
  Serial.print(h);
  Serial.print(""%  Temperature: "");
  Serial.print(t);
  Serial.println(""°C "");

  delay(2000); // Delay between measurements
}
```

Upload the code to the ESP32 and then open the serial monitor.

![[f532c5feeca586db8e20684ccb3e8cb4_MD5.png]]

We can see the temperature and humidity readings, shows as below:

![[821ea0deddc5c5b387ca242aa0cae55f_MD5.png]]

The project upload to github, link: [ESP32-Tutorials/01_DHT11 at main · ESP32Cubes/ESP32-Tutorials (github.com)](https://github.com/ESP32Cubes/ESP32-Tutorials/tree/main/01_DHT11)",,,2024-11-25 12:45:53.436856,2025-07-28 02:08:52.380018,1228,0,1,2,esp32-sensor-dht11-temperature-and-humidity-sensor,4a663a6a49c9977255270dc60d5132aa
30,ESP32 Sensor Tilt Switch,"# Using a Ball Tilt Sensor with ESP32

## Introduction
A ball tilt sensor is a simple but useful device that can detect the orientation or tilt of an object. It finds applications in various fields such as robotics, gaming, and industrial automation. In this post, we will show you how to use a ball tilt sensor with the ESP32 or Arduino. 

## Working Principle

![[tilt_swtich.excalidraw.svg]]

The ball tilt sensor typically consists of a small enclosed container with a conductive ball inside. 

When the sensor is in a vertical direction, the ball will contact two pins. However, when the sensor is in horizontal direction, the connection between two pins are open. So we can use this property to detect the tilt direction.

## Electrical Specifications

- Maximum switch rating: <6mA 24VDC
- Electrical life endurance: >50000 cycles
- Contact Resistance: 2Ω (measured at 45° tilt)

## Wiring

![[9f330d44d64942cd6980d3e2de3ce44a_MD5.png]]

As I measured value, while the ball switch connected the resistor values is about **20Ω**. Therefore, we need to use a resistor to limit the current flowing through the sensor. We can use a 10KΩ resistor in series with the sensor to limit the current.

Below picture is the connection between a title switch model, which already provided resistors, so it just need connect to 3.3V, GND, and GPIO.
![[tilt_swtich_ESP32Cube.jpg]]

Then we can use the ESP32's `digitalRead()` function to read the state of the sensor. When the ball is in the vertical position, the sensor will read HIGH, and when it is in the horizontal position, it will read LOW.

## Code (Using PlatformIO)

1. First, create a new project in PlatformIO and add the necessary dependencies.
2. In the `main.cpp` file, include the relevant libraries and define the GPIO pin to which the sensor is connected.

```cpp
#include <Arduino.h>

// Define the GPIO pin connected to the tilt sensor
const int tiltSensorPin = 25;

void setup() {
  // Initialize the serial communication for debugging (optional but useful)
  Serial.begin(115200);

  // Set the tilt sensor pin as an input
  pinMode(tiltSensorPin, INPUT);
}

void loop() {
  // Read the state of the tilt sensor
  int sensorValue = digitalRead(tiltSensorPin);

  // Print the sensor value to the serial monitor
  Serial.println(sensorValue);

  // Add a delay to avoid reading the sensor too frequently
  delay(100);
}
```

This code initializes the serial communication for debugging purposes (you can view the sensor readings in the serial monitor). It then configures the GPIO pin connected to the tilt sensor as an input and continuously reads the sensor's state. The value is printed to the serial monitor, and a small delay is added to prevent excessive readings.

## Eliminating Signal Jitter

Due to the unstable characteristics of the switch's contact or disconnection, signal jitter can lead to discontinuous output from the sensor. To eliminate signal jitter, we can adopt the following method:

By introducing a delay, we can stabilize the sensor's output to eliminate signal jitter.

```cpp
#include <Arduino.h>

// Define the GPIO pin connected to the tilt sensor
const int tiltSensorPin = 25;
const unsigned long debounceDelay = 50; // Delay to represent the debounce time in milliseconds
int lastSensorValue = -1; // Store the last stable value read from the sensor

void setup() {
  // Initialize the serial communication for debugging (optional but useful)
  Serial.begin(115200);

  // Set the tilt sensor pin as an input
  pinMode(tiltSensorPin, INPUT);
}

void loop() {
  // Read the state of the tilt sensor
  int sensorValue = digitalRead(tiltSensorPin);

  // If the sensor value is different from the last stable value, wait for the debounce time
  if (sensorValue != lastSensorValue) {
    unsigned long startTime = millis();
    while (millis() - startTime < debounceDelay) {
      // Check if the sensor value has changed during the debounce time
      if (digitalRead(tiltSensorPin) != sensorValue) {
        return; // If the value changed, abort this reading
      }
    }
  }

  // If the code reaches this point, the sensor value has been stable for the debounce time
  if (sensorValue != lastSensorValue) {
    lastSensorValue = sensorValue; // Update the last stable value
    Serial.println(sensorValue); // Print the new stable sensor value to the serial monitor
  }

  // Add a delay to avoid reading the sensor too frequently
  delay(100);
}
```

## Application Scenarios

1. **Robotics**: In robots, the ball tilt sensor can be used to detect if the robot is tilting too much while moving on uneven terrains. This information can be used to adjust the robot's balance or change its movement strategy to prevent it from toppling over.
2. **Gaming**: It can be incorporated into gaming controllers to provide additional input based on the tilt of the controller. For example, in a racing game, tilting the controller can be used to steer the virtual car.
3. **Industrial Automation**: In some industrial processes, such as monitoring the orientation of machinery or containers, the ball tilt sensor can be used to ensure that everything is in the correct position. If a container is tilting too much, it may indicate a problem with the filling process or the stability of the setup.
4. **Smart Home Devices**: In smart home applications, it can be used to detect the orientation of objects like window blinds or lamp.

In conclusion, using a ball tilt sensor with the ESP32 opens up a wide range of possibilities for detecting tilt and orientation in various projects. By understanding its working principle, you can easily integrate it into your applications and enhance their functionality. Whether it's for a fun DIY project or a more serious industrial application, the ball tilt sensor and ESP32 combination can be a valuable addition.

Remember to experiment and customize the code according to your specific requirements. Happy coding!",,,2024-11-25 12:45:53.456473,2025-07-28 01:31:08.640718,777,0,1,2,esp32-sensor-tilt-switch,e86c86c1ec4f0066d49cfd1929730c0b
31,Control LED Brightness with ESP32 PWM,"## Overview

Pulse Width Modulation (PWM) is a technique that changes the pulse width while keeping the waveform frequency constant. PWM is primarily used for controlling the brightness of LEDs, the speed of DC motors, controlling servo motors, and any scenario where a digital source is needed to generate an analog signal.
## PWM Terminology

Before diving into the PWM functionality on the ESP32, let's discuss some PWM-related terms:

-   **TON (On Time)**: The duration for which the signal is high.
-   **TOFF (Off Time)**: The duration for which the signal is low.
-   **Period**: The sum of the TON and TOFF of a PWM signal.
-   **Duty Cycle**: The percentage of time within a PWM signal period that the signal is high. 

For example, if a 10ms pulse stays ON (high) for 5ms, then the duty cycle is: 

Duty Cycle = 5/10 \* 100% = 50%.

Here I make a example of to draw lines to demonstrate the PWM effect. The python code:

```python
import numpy as np
import matplotlib.pyplot as plt

fig, axs = plt.subplots(1, 3, figsize=(12, 4))

# different space
spacing_points = [0.1, 0.2, 0.3]

# fix line width
line_width = 0.2

for ax, sp in zip(axs, spacing_points):
    x = np.arange(0, 1, sp / 72)
    y = 1
    ax.vlines(x, ymin=0, ymax=y, colors=""black"", linewidth=line_width)
    ax.set_ylim(0, 1)
    ax.set_title(f""Space: {sp} points"")

plt.suptitle(""Effect of Different Spaces on Appearance (Line Width Fixed at 0.2)"")
plt.tight_layout()
plt.savefig(""pwm.png"", dpi=300)
plt.show()
```

![[b03ef70040c36d7dbca66d0c1f040682_MD5.jpeg]]

The figure shows above, from left to right, the image changes from dark to light. Actually, they are draw by the same color and same width line, we feel the brightness are different is just because the lines with different space.

If turn on and off the LED at a high speed, then watch the LED, it will have the similar effect, but the longer the ON time, the brighter the LED.

## ESP32 LED PWM Controller (LEDC)

The LEDC peripheral of the ESP32 consists of 16 PWM channels capable of generating independent waveforms, primarily used for RGB LED control, but can also be used for other purposes. There are a few interesting points you should note about the LED PWM controller in the ESP32.

-   16 independent PWM channels, divided into two groups of 8 channels each.
-   Programmable resolution between 1 and 16 bits.
-   The frequency of the PWM wave depends on the resolution of the PWM.
-   Automatically increases/decreases duty cycle without processor intervention.

But using PWM in ESP32 is not as simple as that in Arduino development board. Some configuration is required to make it work.

## Configure ESP32's PWM channels

In Arduino programming, the “analogWrite()” function is used to generate PWM signals. However, almost everything in the ESP32’s LED PWM requires user configuration (channels, resolution, and frequency), so we will use a different (and dedicated) set of functions to configure the PWM in the ESP32 instead of using the “analogWrite()” function.

Below is a list of all LEDC APIs exposed by the driver. These functions are written for the Arduino IDE port for the ESP32.

- ledcSetup(channel, frequency, resolution bits)_
- ledcAttachPin(pin, channel);
- ledcWrite(channel, duty cycle);
- ledcRead(channel);
- ledcWriteTone(channel, frequency)
- ledcWriteNote(channel, note, octave);
- ledcReadFreq(channel);
- ledcDetachPin(pin);

Of the 8 functions, we will focus on the first three, as they are more useful (and the minimum required) for generating PWM.

Some important points to remember when configuring PWM channels in ESP32:

-   Since there are 16 PWM channels, the Channels parameter can take any value between 0 and 15.
-   Next is the frequency of the PWM signal. You can set the frequency as per your requirement, such as 1 KHz, 5 KHz, 8 KHz and 10 KHz.
-   The resolution of the PWM is also configurable, the ESP32 PWM can be programmed anywhere between 1 bit to 16 bits of resolution.
-   PWM frequency and resolution are inversely proportional and depend on the clock source. Therefore, be careful when choosing frequency and resolution values.
-   Finally, assign GPIO pins for PWM output. You can assign any GPIO pins, but be careful when assigning (do not use GPIO pins that are already in use, such as UART, SPI, etc.).

The following table shows some commonly used PWM frequencies and resolutions.

| **LEDC Clock Source** | **LEDC PWM frequency** | **PWM resolution** |
| --- | --- | --- |
| 80 MHz APB\_CLK | 1KHz | 16-bit |
| 80 MHz APB\_CLK | 5KHz | 14-bit |
| 80 MHz APB\_CLK | 10KHz | 13th |
| 8 MHz RTC8M\_CLK | 1KHz | 13th |
| 8 MHz RTC8M\_CLK | 8KHz | 10-bit |
| 1 MHz REF\_Tick | 1KHz | 10-bit |

## Achieve results

In this experiment, the LED light on the ESP32 development board will be used as a PWM-controlled LED light to achieve a breathing effect.

ESP32 board has an LED light and can be controlled via GPIO 2

## Program Code

```Arduino
const int LEDPin = 2;  /* GPIO16 */

int dutyCycle;
/* Setting PWM Properties */
const int PWMFreq = 5000; /* 5 KHz */
const int PWMChannel = 0;
const int PWMResolution = 10;
const int MAX_DUTY_CYCLE = (int)(pow(2, PWMResolution) - 1);

void setup()
{  
  // Configure PWM channel, frequency, and resolution
  ledcSetup(PWMChannel, PWMFreq, PWMResolution);
  // Attach the configured PWM channel to the specified pin
  ledcAttachPin(LEDPin, PWMChannel);
}

void loop()
{
  // Increase LED brightness using PWM
  for(dutyCycle = 0; dutyCycle <= MAX_DUTY_CYCLE; dutyCycle++)
  {
    ledcWrite(PWMChannel, dutyCycle);
    delay(3); // Delay to control the brightness change speed
  }
  
  // Decrease LED brightness using PWM
  for(dutyCycle = MAX_DUTY_CYCLE; dutyCycle >= 0; dutyCycle--)
  {
    ledcWrite(PWMChannel, dutyCycle);
    delay(3); // Delay to control the brightness change speed
  }
}

```

One of the important features of PWM in ESP32 is that all 16 channels can be configured independently, that is, each channel can have its own resolution and frequency.","This article focuses on the ESP32 board's PWM capabilities, detailing key terms like TON, TOFF, period, and duty cycle, essential for understanding PWM applications and implementation.",,2024-11-25 12:45:53.489373,2025-07-27 23:16:39.056772,808,0,1,2,control-led-brightness-with-esp32-pwm,374971bfdfeaf3a49b225b8c132adfc1
32,ESP32 PWM Output,"This article explains how to use the Pulse Width Modulation (PWM) functionality of ESP32 to control the brightness of an LED.

## Introduction

The ESP32 Arduino environment doesn't have the common `analogWrite` Arduino function. So, we need to use low-level functions as shown in this tutorial. But this gives us more control and flexibility in PWM.

In terms of hardware, the ESP32's LED PWM has 16 independent channels with configurable duty cycles and wave periods. The duty cycle's precision can be set up to a 16-bit resolution.

## Components List

- ESP32 development board
- One LED (I'm using a 5mm red LED)
- Breadboard
- Several jumper wires

## Circuit Diagram

![[67403c0d5a485afe1c9d44b5e04d802c_MD5.png]]

## Code Design

**1. Initialization Setup**

In the initial part of the code, we define some global configuration constants. The first one is the frequency of the PWM signal for controlling the LED. We'll use 5000Hz. But note that the maximum frequency isn't clear and depends on the chosen resolution, as stated in the [header file](https://github.com/espressif/arduino-esp32/blob/a4305284d085caeddd1190d141710fb6f1c6cbe1/cores/esp32/esp32-hal-ledc.h#L29) of the function we'll use.

We'll specify the LED PWM channel and the resolution in bits. From the header file, we can see that we can select a channel from 0 to 15 and a resolution from 1 to 16 bits. Here, we'll use channel 0 and an 8-bit resolution.

```cpp
int freq = 5000;
int ledChannel = 0;
int resolution = 8;
```

Next, in the setup function, we configure the LED PWM. First, we need to set the channel, frequency, and resolution we specified. We do this by calling the [ledcSetup](https://github.com/espressif/arduino-esp32/blob/a4305284d085caeddd1190d141710fb6f1c6cbe1/cores/esp32/esp32-hal-ledc.h#L30) function, which takes the three parameters mentioned above in the same order.

```cpp
ledcSetup(ledChannel, freq, resolution);
```

It's important to note that the channel isn't the GPIO pin controlling the LED. So, we need to connect **channel 0** (the one we defined) to the digital GPIO pin where we want to generate the PWM signal. In my case, I'm connecting it to GPIO pin 2. We use the [ledcAttachPin](https://github.com/espressif/arduino-esp32/blob/a4305284d085caeddd1190d141710fb6f1c6cbe1/cores/esp32/esp32-hal-ledc.h#L36) function, passing the GPIO pin number and the previously defined PWM channel as arguments.

```cpp
ledcAttachPin(2, ledChannel);
```

Here's the complete initialization setup along with constant definitions:

```cpp
#define LED_PWM 2 // Define the GPIO pin being used for the call
int freq = 5000;
int ledChannel = 0;
int resolution = 8;
void setup() {
    ledcSetup(ledChannel, freq, resolution);
    ledcAttachPin(LED_PWM, ledChannel);
}
```

## 2. In the Main Loop

We'll write code to control the duty cycle value of the signal in the Arduino main loop. The most important function for specifying the duty cycle value is the [ledcWrite](https://github.com/espressif/arduino-esp32/blob/a4305284d085caeddd1190d141710fb6f1c6cbe1/cores/esp32/esp32-hal-ledc.h#L31) function, which takes the PWM channel (not the GPIO number) as its first parameter.

Since we defined an 8-bit resolution, we can set duty cycle values between 0 and 255 (which is $2^8 - 1$). Therefore, we go through these values in two loops, one increasing and the other decreasing. The following is the complete source code, including calls to the **ledcWrite** function and these two loops.

```cpp
/*******************************************************
   ESP32 PWM Breathe LED
   Function: Achieve LED breathing effect
   Pin: D2 (GPIO2)
*******************************************************/

#define LED_PWM 2 // Define the GPIO pin being used for the call
int freq = 5000;
int ledChannel = 0;
int resolution = 8;

void setup() {
    ledcSetup(ledChannel, freq, resolution);
    ledcAttachPin(LED_PWM, ledChannel);
}

void loop() {
    for (int dutyCycle = 0; dutyCycle <= 255; dutyCycle++) {
        ledcWrite(ledChannel, dutyCycle);
        delay(7);
    }
    for (int dutyCycle = 255; dutyCycle >= 0; dutyCycle--) {
        ledcWrite(ledChannel, dutyCycle);
        delay(7);
    }
}
```

## Testing the Code

To test the code, simply upload it using the Arduino IDE. You should then see the LED breathing effect.","This article details how to utilize ESP32's PWM feature to manage LED brightness, covering components, code, and testing.",,2024-11-25 12:45:53.527591,2025-07-27 23:06:38.638905,1285,0,1,2,esp32-pwm-output,2e5d7d84d2a6ba26aa50c79b3a8259f0
33,Deploy to Server with GitHub Actions,"This guide will show you how to set up a GitHub Actions workflow to automatically update your server content whenever you push your code to GitHub.

## Step-by-Step Guide:

1. **Generate SSH Keys**:
   - On your local machine, generate an SSH key pair (if you don't have one) using the command:
     ```bash
     ssh-keygen -t ed25519 -C ""your_email@example.com""
     ```
   - This will create a private key (`id_ed25519`) and a public key (`id_ed25519.pub`).

2. **Configure the Server**:
   - Copy the contents of the public key (`id_ed25519.pub`) to the server's `~/.ssh/authorized_keys` file:
     ```bash
     cat id_ed25519.pub >> ~/.ssh/authorized_keys
     ```
   - Ensure the permissions are set correctly:
     ```bash
     chmod 700 ~/.ssh
     chmod 600 ~/.ssh/authorized_keys
     ```

3. **Add Private Key to GitHub**:
   - In your GitHub repository, go to `Settings` → `Secrets and variables` → `Actions`.
   - Click on `New repository secret` to add the SSH private key:
     - **Name**: `SSH_PRIVATE_KEY`
     - **Value**: Paste the contents of your private key (`id_ed25519`).
   - Also, add the following secrets:
     - **Name**: `HOST`, **Value**: Your server's IP address or domain.
     - **Name**: `USERNAME`, **Value**: Your server’s username.

4. **Create GitHub Actions Workflow**:
   - In your GitHub repository, create a directory `.github/workflows` if it doesn't exist.
   - Create a file named `deploy.yml` inside the `.github/workflows` directory with the following content:

```yaml
name: Deploy to Server

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Copy files to server
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.USERNAME }}@${{ secrets.HOST }} ""cd /www/wwwroot/Django_ESP32 && git pull""
```

5. **Push to GitHub**:
   - Whenever you push changes to the `main` branch of your GitHub repository, the GitHub Actions pipeline will trigger.
   - It will check out your code, set up the SSH connection, and execute the command to pull the latest code on your server.

## Result:
Upon each push to the main branch of your repository, the latest code will automatically be pulled onto your specified server directory, keeping your server's content updated with your GitHub repository.

This setup allows for a streamlined deployment process, making it easier to manage code updates without manual intervention.","This blog shows you how to use GitHub Actions to automatically update your server when pushing code. It covers generating SSH keys, configuring the server, adding keys to GitHub, creating the workflow, and the final result.",,2024-11-26 00:25:00.432390,2025-07-28 01:59:33.198283,735,0,1,2,deploy-to-server-with-github-actions,65e6529314c128f1dbf9bbfb64726ceb
34,Bounce2 Library for Arduino Debouncing Made Easy,"Bounce2 library provides an efficient debouncing algorithm to filter the noise signal of the key switches, ensuring that the program only responds to valid key operations. This is critical for the projects that rely on key input, preventing program errors or unexpected behaviors.

While we push or release the button, the signal will looks as below figure, we can see that there are some small vibrations in the signal at the beginning of button state change.

![[Pasted image 20241126132833.jpeg]]

![[Pasted image 20241126133004.jpeg]]

## Introduction

The Bounce2 library is mainly composed of three classes:
- `Bounce2::Button`: This is the most commonly used class in the library and has the lots of functions. It is specifically designed for debouncing hardware buttons. Usually, only use this class is enough for the applications.
- `Debouncer`: This is the class responsible for the actual debouncing algorithm in the library. Only advanced users need to directly use this class to create their own debouncing implementation.
- `Bounce`: This class connects the Debouncer class to the hardware pin. Its naming is a bit strange because it is to maintain backward compatibility with earlier versions of the library.

## Installation

Installing the Bounce2 library is straightforward. You can search and install it via the Arduino IDE's library manager or download the source code and copy the ""Bounce2"" folder to the ""libraries"" folder of the Arduino IDE.

## Example

Here's a basic example of how to use the `Bounce2::Button` class for key debouncing:

```cpp
#include <Bounce2.h>

Bounce2::Button button = Bounce2::Button();

// Configuration in the setup() function
void setup() {
  button.attach(PIN, INPUT_PULLUP); // Connect the button to the specified pin with an internal pull-up resistor
  button.interval(5); // Set the debounce time interval to 5 milliseconds
  button.setPressedState(LOW); // Set the level state when the button is pressed to LOW
}

// Updating and detecting the button state in the loop() function
void loop() {
  button.update(); // Update the button state
  if (button.pressed()) {
    // Operations to perform when the button is pressed
  }
}
```

In the above code, the `button.attach()` function connects the `Bounce2::Button` object to the specified hardware pin, `button.interval()` sets the debounce time interval, and `button.setPressedState()` sets the level state when the button is pressed.

The Bounce2 library offers advanced functions like `released()` to detect button release, `isPressed()` to check if the button is currently pressed, and `changed()` to detect if the button state has changed.

It also provides three different debouncing algorithms: Stable Interval (default), Lock-out Interval (enabled by defining `#define BOUNCE_LOCK_OUT` in ""Bounce.h""), and Prompt Detection (enabled by defining `#define BOUNCE_WITH_PROMPT_DETECTION` in ""Bounce.h"").

## Summary

The Bounce2 library is a powerful and easy-to-use debouncing library for Arduino. Its clear documentation and rich example codes make it accessible for developers to quickly apply in practical projects, whether for simple key control or applications requiring precise time measurement.

Project address: https://github.com/thomasfredericks/Bounce2","The Bounce2 library is a easy use tool for Arduino platforms, it will help us to solve the problem of erroneous states caused by the tiny vibrations of mechanical key switches when they are closed or opened.",,2024-11-26 05:35:46.820393,2025-07-28 00:05:33.017054,1469,0,1,2,bounce2-library-for-arduino-debouncing-made-easy,5386b95ae37050ec7d8992ab5c551809
35,ESP32Encoder Library for Rotation Encoder Reading,"The ESP32Encoder library is a software library that enables efficient reading of rotation encoders by leveraging the pulse counter hardware peripheral of the ESP32. It offers numerous advantages such as high efficiency, low interrupt load, and multi-channel support, making it an ideal choice for handling rotation encoders in IoT and embedded projects.

![[Pasted image 20241126203651.jpeg]]

## What is ESP32Encoder?

ESP32Encoder is an open-source library for the ESP32 microcontroller. It utilizes the built-in pulse counter (PCNT) hardware peripheral of the ESP32 to read the signals from rotation encoders. Compared to software polling methods, this library uses hardware interrupt handling, significantly reducing the CPU load and improving the reading accuracy and efficiency. It is especially suitable for applications that require real-time processing of rotation encoder data.

## What can ESP32Encoder do?

ESP32Encoder is mainly used to read various types of rotation encoders, such as incremental encoders, and convert them into digital signals for subsequent processing by the microcontroller. This is crucial in many applications, such as:

- **Robot control**: Precise control of the joint angles, speeds, and positions of robots.
- **Industrial automation**: Monitoring and controlling the operating status of various mechanical equipment.
- **Instrumentation**: Reading values on knobs or dials.
- **User interface**: As a human-computer interaction method, such as volume adjustment, menu selection, etc.
![[Rotation Encoder.jpeg]]
The core functions and features of ESP32Encoder:

- **Hardware acceleration**: Utilizes the PCNT hardware peripheral of the ESP32 for counting, greatly reducing the software processing burden and improving efficiency and accuracy.
- **Low interrupt load**: Only one interrupt is used to handle counter overflows, significantly reducing the CPU overhead of interrupt processing and ensuring stable system operation.
- **Multi-channel support**: Supports up to 8 simultaneous encoders (for ESP32 and ESP32C2), and ESP32S3 supports 2.
- **Multiple counting modes**: Supports three modes: full four-quadrant counting, half four-quadrant counting, and single-edge counting to adapt to different types of encoders and application requirements.
- **Internal weak pull-up/pull-down resistors**: Configurable internal weak pull-up/pull-down resistors simplify the circuit design.
- **Configurable interrupt service CPU core**: Allows users to specify the CPU core on which the interrupt service routine runs to avoid concurrency issues.
- **Hardware debouncing**: Provides hardware debouncing functionality to effectively filter out jitter noise in the encoder signals. For encoders like KY-040 that are prone to jitter, external capacitors for debouncing and appropriate filtering parameters need to be set.
- **Easy to use**: Offers a simple API interface for users to quickly integrate into their projects.
- **Good documentation**: Provides detailed documentation generated by Doxygen for users to consult and learn.

Compatibility:

- Supports ESP32 and ESP32-C2 chips.
- ESP32-C3 is not supported as this chip does not have a pulse counter hardware.
- ESP32-S3 has only two PCNT modules, so only two hardware-accelerated encoders are supported.

## Example

```c
#include <ESP32Encoder.h>

ESP32Encoder encoder1(2, 4); // Connect the encoder using GPIO 2 and 4

void setup() {
  Serial.begin(115200);
  encoder1.setFilter(1023); // Set the maximum hardware debounce
  encoder1.setCount(0); // Set the initial count to 0
}


void loop() {
    long count = encoder1.getCount();
    Serial.print(""Encoder Count: "");
    Serial.println(count);
    delay(100);
}
```

Notes on KY-040 and similar encoders:

Switch-type encoders like KY-040 are prone to significant signal jitter and require external capacitors for debouncing (typically between 0.1uF and 2uF). Also, when using the ESP32Encoder library, `setFilter(1023)` needs to be set to achieve the maximum hardware debouncing effect.

## Conclusion:

The ESP32Encoder library is an efficient, easy-to-use, and powerful rotation encoder reading library. It fully utilizes the hardware resources of the ESP32, greatly simplifies the use of encoders, and improves system performance. Whether for simple applications or complex projects, ESP32Encoder can provide a reliable rotation encoder reading solution.

Project address: https://github.com/madhephaestus/ESP32Encoder","This blog post presents the ESP32Encoder library, detailing its features and capabilities for efficient rotation encoder reading. It explains how it simplifies encoder usage and boosts system performance, suitable for various applications.",Rotation Encoder.jpeg,2024-11-26 13:49:18.276193,2025-07-27 22:27:15.315861,2404,0,1,2,esp32encoder-library-for-rotation-encoder-reading,e665938cca2263bc6a57a800de0f048d
36,Introduction to the Powerful MultiButton Key Driver Module,"## Introduction

MultiButton is a simple, easy-to-use, and powerful key driver module. It is based on the event-driven mechanism and adopts the object-oriented design concept, which can help you manage multiple keys easily and handle key events in an asynchronous callback manner. Thus, it simplifies your code structure and makes the key logic clearer and more flexible!

The core advantages of MultiButton

- Unlimited key expansion: Supports any number of keys without modifying the core code for easy expansion.
- Event-driven mechanism: Based on the event-driven mechanism, various key events such as press, release, single click, double click, long press, etc., can be easily defined and handled.
- Asynchronous callback mechanism: The processing function of key events adopts an asynchronous callback method to avoid blocking the main program and make your code structure clearer.
- Object-oriented design: Each key object has an independent data structure and state management, which are independent of each other for easy management.
- Code simplification: Using MultiButton can simplify the key processing code, reduce duplicate code, and improve code readability and maintainability.

## Steps to use MultiButton

1. Apply for the key structure:

```c
struct Button button1;
```

2. **Initialize the key object**: Bind the GPIO level reading interface of the key and the valid trigger level.

```c
button_init(&button1, read_button_pin, 0, 0);
```

3. **Register key events**: Bind the callback function for each key event.

```c
button_attach(&button1, SINGLE_CLICK, Callback_SINGLE_CLICK_Handler);
button_attach(&button1, DOUBLE_CLICK, Callback_DOUBLE_Click_Handler);
```

4. **Start the key**:

```
button_start(&button1);
```

5. **Set the timer**: Call the `button_ticks()` function regularly for key state update.

```c
while(1) {
    ...
    if(timer_ticks == 5) {
        timer_ticks = 0;

        button_ticks();
    }
}
```

## The data structure of MultiButton

MultiButton is implemented in C language, and each key object is managed using an independent data structure:

```c
struct Button {
    uint16_t ticks;                     // Timer
    uint8_t  repeat : 4;                // Repeat press count
    uint8_t  event  : 4;                // Event identifier
    uint8_t  state  : 3;                // Current state
    uint8_t  debounce_cnt : 3;          // Debounce counter
    uint8_t  active_level : 1;          // Active level (high/low)
    uint8_t  button_level : 1;          // Current button level (high/low)
    uint8_t  button_id;                 // Button ID
    uint8_t (*hal_button_Level)(uint8_t button_id_); // Pointer to hardware button level function
    BtnCallback cb[number_of_event];    // Array of callback functions for button events
    struct Button* next;                 // Pointer to the next button in the linked list
};

```

Each key object is connected through a singly linked list and enters the `button_handler(struct Button* handle)` state machine for processing in sequence to ensure that the state of each key is independent.

## The key events supported by MultiButton

| Event              | Description                                                                                      |
| ------------------ | ------------------------------------------------------------------------------------------------ |
| `PRESS_DOWN`       | Key press, triggered each time the key is pressed.                                               |
| `PRESS_UP`         | Key release, triggered each time the key is released.                                            |
| `PRESS_REPEAT`     | Triggered when the key is repeatedly pressed, `repeat` counts the number of consecutive presses. |
| `SINGLE_CLICK`     | Single-click key event.                                                                          |
| `DOUBLE_CLICK`     | Double-click key event.                                                                          |
| `LONG_PRESS_START` | Triggered once when the long press time threshold is reached.                                    |
| `LONG_PRESS_HOLD`  | Triggered continuously during the long press.                                                    |

## Example code

```c
#include ""button.h""

unit8_t btn1_id =0;

struct Button btn1;

uint8_tread_button_GPIO(uint8_t button_id)
{
// you can share the GPIO read function with multiple Buttons
switch(button_id)
{
case btn1_id:
return HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin);
break;

default:
return0;
break;
}
}

voidBTN1_PRESS_DOWN_Handler(void* btn)
{
//do something...
}

voidBTN1_PRESS_UP_Handler(void* btn)
{
//do something...
}

...

intmain()
{
    button_init(&btn1, read_button_GPIO,0, btn1_id);
    button_attach(&btn1, PRESS_DOWN,       BTN1_PRESS_DOWN_Handler);
    button_attach(&btn1, PRESS_UP,         BTN1_PRESS_UP_Handler);
    button_attach(&btn1, PRESS_REPEAT,     BTN1_PRESS_REPEAT_Handler);
    button_attach(&btn1, SINGLE_CLICK,     BTN1_SINGLE_Click_Handler);
    button_attach(&btn1, DOUBLE_CLICK,     BTN1_DOUBLE_Click_Handler);
    button_attach(&btn1, LONG_PRESS_START, BTN1_LONG_PRESS_START_Handler);
    button_attach(&btn1, LONG_PRESS_HOLD,  BTN1_LONG_PRESS_HOLD_Handler);
    button_start(&btn1);

//make the timer invoking the button_ticks() interval 5ms.
//This function is implemented by yourself.
    __timer_start(button_ticks,0,5);

while(1)
{}
}
```

## Conclusion

MultiButton is a simple, easy-to-use, and powerful key driver module that can help you manage multiple keys easily and handle key events in an asynchronous callback manner. Using MultiButton can simplify the key processing code, improve code readability and maintainability, and make your key logic clearer and more flexible!

Project address: https://github.com/0x1abin/MultiButton","MultiButton a powerful and easy-to-use key driver module. It explains its core advantages, usage steps, data structure, supported events, and provides example code.",,2024-11-26 13:49:18.353083,2025-07-28 01:49:34.548581,705,0,1,2,introduction-to-the-powerful-multibutton-key-driver-module,f80d0d14c5ad1e50d3331a30a3ea0030
37,SFP56 Testing Board Design Note,"There are multiple types of SFP connectors:

- **SFP** 20 pin connector supporting a variety of speeds
- **SFP+** Same as SFP but supporting up to 16 Gbps
- **SFP28** Also 20 pins, but in an alternative form factor and supporting higher data rates
- **SFP56** Same as SFP28 but with higher speed limit

## SFP56 Connector Pin

While we using a connector, one of the trouble thing is to find the right pin define. Some time it will confuse and very easy to make mistake. We'd better to check the pin define with a sample of SFP connector before we start designing the board .

Here is the pin define of SFP56 connector:

![[Pasted image 20241129125422.jpeg]]

SFP pin number, view from front

| Pin | Symbol  | Name/Description                                               | Notes |
| --- | ------- | -------------------------------------------------------------- | ----- |
| 1   | VEET    | Transmitter Ground (Common with Receiver Ground)               | 1     |
| 2   | TFAULT  | Transmitter Fault.                                             | 2,3   |
| 3   | TDIS    | Transmitter Disable. Laser output disabled on high or open.    | 4     |
| 4   | SDA     | 2 - wire Serial Interface Data Line                            | 2     |
| 5   | SCL     | 2 - wire Serial Interface Clock Line                           | 2     |
| 6   | MOD_ABS | Module Absent. Grounded within the module                      | 5     |
| 7   | RS0     | Rate Select 0.                                                 | 5     |
| 8   | RX_LOS  | Loss of Signal indication. Logic 0 indicates normal operation. | 6     |
| 9   | RS1     | Rate Select 1.                                                 | 5     |
| 10  | VEER    | Receiver Ground (Common with Transmitter Ground)               | 1     |
| 11  | VEER    | Receiver Ground (Common with Transmitter Ground)               | 1     |
| 12  | RD -    | Receiver Inverted DATA out. AC Coupled                         |       |
| 13  | RD +    | Receiver Non - inverted DATA out. AC Coupled                   |       |
| 14  | VEER    | Receiver Ground (Common with Transmitter Ground)               | 1     |
| 15  | VCCR    | Receiver Power Supply                                          | 7     |
| 16  | VCCT    | Transmitter Power Supply                                       | 7     |
| 17  | VEET    | Transmitter Ground (Common with Receiver Ground)               | 1     |
| 18  | TD +    | Transmitter Non - Inverted DATA in. AC Coupled.                |       |
| 19  | TD -    | Transmitter Inverted DATA in. AC Coupled.                      |       |
| 20  | VEET    | Transmitter Ground (Common with Receiver Ground)               | 1     |

Notes:

1. Circuit ground is internally isolated from chassis ground.
2. Open collector/drain output, which should be pulled up with a 4.7k to 10k Ohm resistor on the host board if intended for use. Pull up voltage should be between 2.0V to Vcc + 0.3V.
3. A high output indicates a transmitter fault caused by either the TX bias current or the TX output power exceeding the preset alarm thresholds. A low
output indicates normal operation. In the low state, the output is pulled to <0.8V.
4. Laser output disabled on TDIS >2.0V or open, enabled on TDIS <0.8V.
5. Internally pulled down per SFF-8431 Rev 4.1.
6. LOS is open collector output. Should be pulled up with 4.7k to 10kΩ on host board to a voltage between 2.0V and Vcc + 0.3V. Logic 0 indicates normal operation; logic 1 indicates loss of signal.
7. Internally connected.

## SFP Connector Footprint

We need solder the SFP connector to the board. So it also need to know the footprint of SFP connector. This image direction is same as the above connector picture. The pin 1 is on the left bottom corner. And there are two holes on the PCB for connector alignment.

![[Pasted image 20241129131429.jpeg]]

## Layout Consideration

Some suggestion from [Zachariah Peterson](https://resources.altium.com/p/how-use-sfp-connectors-your-pcb-layout)

 - On the right side of the connector, there are I2C interface and some control signals. All of these are low speed and should generally be routed away from the high-speed differential pairs coming to the left side. 
 ![[Pasted image 20241129134454.jpeg]]
- the high-speed signals enter from the left side, and they are surrounded by GND and PWR pins. The Rx and Tx input/output differential pairs on L1 are marked with yellow arrows:
![[Pasted image 20241129134710.jpeg]]
- These lines are passing into the inner layers using differential vias, the vias drop down to L6 in an 8-layer PCB. Because the outer two dielectrics are thin (11 mil total thickness), the stub length is already minimized on this via transition and backdrilling is not needed. The differential pairs pass through an optimized antipad that sets the required differential impedance to 100 Ohms up to a bandwidth of approximately 10 GHz.
![[Pasted image 20241129134903.jpeg]]
- Power Integrity
![[71c60a3635ca0ef8f7756bc850ac50da_MD5.png]]

Filter circuit used on the 3V3 rail for powering the transceiver module.
![[Pasted image 20241129135756.jpeg]]

## SFP Memory Define

[SFF-8472](https://members.snia.org/document/dl/25916) defines the digital interface of SFP module.

- The interface is accessed via the I2C interface.
- It using two 8-bit addresses: 1010000X (A0h) and 1010001X (A2h),.

A general overview of the memory map is shown below:

![[Pasted image 20241129160230.jpeg]]",I will record the note of design a SFP56 Testing board.,,2024-11-29 08:19:55.191300,2025-07-28 01:33:34.532043,799,0,1,1,sfp56-testing-board-design-note,378ad81fcadaebcac02f9a7d49bc5fe2
39,Remote Control of Light Switch using ESP32,"In this tutorial, we'll walk you through the process of creating an IoT application that enables remote control of a light switch using the ESP32 microcontroller. You'll use VS Code, PlatformIO, and a few additional components to achieve this. By the end of this tutorial, you'll have a working prototype where you can remotely toggle a light switch on or off using your smartphone or computer.

## Hardware List

To complete this project, you'll need the following components:

1.  ESP32 Development Board
2.  Relay Module
3.  AC Light Bulb (or any other load you want to control)
4.  Jumper Wires
5.  Breadboard
6.  USB Cable (for powering the ESP32)

## Step 1: Setting Up the Hardware

1.  Connect the relay module to the ESP32 following these connections:
    
    -   VCC to 3.3V on ESP32
    -   GND to GND on ESP32
    -   IN to a digital pin (e.g., GPIO 4) on ESP32

2.  Connect the relay module to the AC light bulb:
    
    -   Connect one terminal of the light bulb to the Common (COM) terminal of the relay.
    -   Connect the other terminal of the light bulb to the Normally Open (NO) terminal of the relay.

## Step 2: Creating the Software

1.  Set up your development environment following the same steps as outlined in the previous tutorial.
2.  In the `src` folder, create a new source code file, for example, `main.cpp`.
3.  Write the code to control the relay and enable remote control using Wi-Fi. Here's a basic example:

```c
#include <Arduino.h>
#include <WiFi.h>

const char* ssid = ""your_wifi_ssid"";
const char* password = ""your_wifi_password"";

const int relayPin = 4; // Relay module connected to GPIO 4

void setup() {
  Serial.begin(115200);
  pinMode(relayPin, OUTPUT);

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println(""Connecting to WiFi..."");
  }
  Serial.println(""Connected to WiFi"");
}

void loop() {
  // Check for incoming commands to control the relay
  // For example, you can use MQTT or a simple HTTP server

  // Toggle the relay based on the command received
  // Example: digitalWrite(relayPin, HIGH); // Turn ON
  //          dig italWrite(relayPin, LOW);  // Turn OFF

  delay(1000);
}
```

## Step 3: Uploading and Testing

1.  Connect the ESP32 to your computer and upload the code following the same steps as outlined in the previous tutorial.
2.  Power on the light bulb and ensure it's connected to the relay.
3.  Access the ESP32's IP address from your web browser or use a mobile app to send commands to toggle the light switch.

Congratulations! You've successfully created a remote-controlled light switch using the ESP32. You can further enhance this project by integrating MQTT for more advanced control or by designing a mobile app for a user-friendly interface.

Remember to always prioritize safety when working with high-voltage components like AC light bulbs. Have fun experimenting and customizing your IoT application!","This tutorial explains how to build an IoT application to control a light switch remotely using the ESP32 microcontroller, Wi-Fi, and a relay module.",,2024-11-29 13:36:42.202660,2025-07-27 23:00:26.038329,1066,0,1,2,remote-control-of-light-switch-using-esp32,b7e123041d84e629e8395eaaca2ddff7
40,"Building Application with ESP32, VS Code, and PlatformIO","In this tutorial, we will guide you through the process of creating a simple IoT application using the ESP32 microcontroller, VS Code as the code editor, and PlatformIO as the development environment. By the end of this tutorial, you will have a basic understanding of setting up an IoT project and communicating with the ESP32 over Wi-Fi.

## Prerequisites

1.  Make sure you have VS Code installed on your computer.
2.  Obtain an ESP32 development board and ensure it can be connected to your computer.

## Step 1: Setting Up the Environment

1.  Launch VS Code and install the PlatformIO extension from the VS Code Marketplace.
2.  Connect your ESP32 development board to your computer through a USB cable.

## Step 2: Creating a New Project

1.  Open VS Code, click on ""File"" -> ""New Folder,"" and create a new folder for your project.
2.  In the terminal within the newly created folder, initialize a new PlatformIO project by running: `platformio init --board esp32dev`
3.  Inside the project folder, create a subfolder named `src` to store your source code files.

## Step 3: Writing the Code

1.  In the `src` folder, create a new source code file, for example, `main.cpp`.
2.  Write the IoT application code for the ESP32. This example demonstrates connecting to a Wi-Fi network. Add the following code to your `main.cpp`:

```arduino
#include <Arduino.h>
#include <WiFi.h>

const char* ssid = ""your_wifi_ssid"";
const char* password = ""your_wifi_password"";

void setup() {
  Serial.begin(115200);

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println(""Connecting to WiFi..."");
  }
  Serial.println(""Connected to WiFi"");

  // Add more initialization code here
}

void loop() {
  // Add loop code here, such as data transmission, sensor readings, etc.
}
```

## Step 4: Uploading and Running

1.  Connect the ESP32 development board to your computer via USB, and ensure you've selected the correct board port.
2.  In VS Code, click on the PlatformIO icon and select ""Upload"" to compile and upload the code to the ESP32.
3.  Open the Serial Monitor in VS Code to view the ESP32's output. Verify that everything is running smoothly.

## Step 5: Extending the Application

1.  Depending on your project requirements, you can add more features, such as sensor data collection, remote control, data storage, etc.
2.  Refer to the ESP32, PlatformIO, and Arduino documentation for more information about functions and libraries.

Congratulations! You've successfully created a basic IoT application using the ESP32, VS Code, and PlatformIO. This tutorial provides a foundation for further exploration and development in the world of IoT.

Feel free to customize and expand upon this tutorial based on your project's needs and your interests. For more advanced topics and features, continue exploring the ESP32 documentation and the capabilities of PlatformIO.

We hope this tutorial helps you kickstart your journey into IoT application development!","This tutorial shows how to building a simple IoT application with ESP32, VS Code, and PlatformIO. It covers setup, project creation, coding, uploading, and extending features for IoT development.",,2024-11-29 13:36:42.232424,2025-07-27 22:27:15.366483,2645,1,1,2,building-application-with-esp32-vs-code-and-platformio,9f29c15ee2b2f3de19e838d1d3afd54e
41,ESP32 with ChatGPT for voice input,"To use ESP32 with ChatGPT for voice input and feedback, you'll need a few components and a development approach. Here are some suggestions for hardware and code development:

In order to get the user voice input and provide voice feedback, it need below hardwares.

Hardware:

1.  ESP32 Development Board: Choose a suitable ESP32 development board. There are many options available with different features and form factors. Some popular choices include the ESP32 DevKitC, NodeMCU-32S, and Wemos D1 Mini ESP32.
2.  Microphone: You'll need a microphone module to capture voice input. You can use modules such as the MAX9814 Electret Microphone Amplifier or the INMP441 MEMS Microphone.
3.  Speaker: To provide feedback or output the synthesized voice generated by ChatGPT, you'll need a speaker or audio output module. You can use a small amplified speaker or an audio breakout board, such as the MAX98357A or the DFPlayer Mini MP3 Player.

To make things simple, I choose the voice development kit from Espressif.

Code Development:

1.  Setting up the Environment: Install the Arduino IDE or PlatformIO as mentioned earlier. Make sure you have the ESP32 board support package installed.
2.  Voice Input: To capture voice input, you'll need to interface the microphone module with the ESP32. Depending on the specific module you're using, you may need to connect it to the appropriate pins on the ESP32. You can use the ESP32 ADC (Analog-to-Digital Converter) to read the microphone's analog output.
3.  Communication: You'll need to establish communication between the ESP32 and the ChatGPT model. One approach is to use Wi-Fi to send the voice input from the ESP32 to a server or cloud service running the ChatGPT model. You can utilize the ESP32's built-in Wi-Fi capabilities to connect to your network and send the voice input over HTTP or MQTT.
4.  Voice Synthesis: Once the voice input is processed by the ChatGPT model, you'll receive text output. To convert the text into synthesized voice feedback, you can utilize text-to-speech (TTS) libraries or services. There are various TTS options available, including offline libraries like Festival and online services like Google Text-to-Speech.
5.  Audio Output: Connect the audio output module or speaker to the ESP32. Depending on the module, you might need to use the ESP32's digital pins for audio output. Use the appropriate libraries and functions to generate audio from the synthesized text and play it through the speaker.
6.  Code Integration: Integrate the voice input, communication, voice synthesis, and audio output code sections together in your ESP32 project. Handle the voice input, send it to the ChatGPT model, receive the generated text, convert it to speech, and output it through the speaker.

Remember to handle any necessary error checking, timeouts, and data formatting to ensure smooth communication and feedback.

It's important to note that implementing ChatGPT on ESP32 may have limitations due to the memory and processing constraints of the ESP32. The model size, complexity, and memory requirements should be considered to ensure they fit within the ESP32's capabilities.","This tutorial discusses using ESP32 with ChatGPT for voice input and feedback. It covers required hardware, code development, and integration methods.",,2024-11-29 13:36:42.258730,2025-07-28 00:11:33.788155,1382,1,1,2,esp32-with-chatgpt-for-voice-input,b6c41aa3b09baad1b40dd942fcf0a1f1
42,ESP32 with LVGL Setp2 Config TFT_eSPI with PlatformIO,"On last article, [[301_screen_step1]] we have introduced how to install and set up the TFT_eSPI library in the ESP32 board.

On this article, we will show you how to install and set up the lvgl library in the ESP32 board.

## Install and Setup TFT_eSPI library

The TFT_eSPI library is a hardware-specific library that is designed to be used with the ESP32 and ESP8266 boards.

To install and set up the library, follow these steps declared in the [[301_screen_step1]].
## Install lvgl library

Search for the lvgl library in the PlatformIO library manager and install it.
### Create a lv_conf.h file

Create a new file `lv_conf.h` under lvgl library root folder. And copy the content from `lv_conf_template.h`. Update the file by enabling the following options.

```c
/* clang-format off */
#if 1 /*Set it to ""1"" to enable content*/
```
## Lighting the screen by a mini example

Although the lvgl library has provided a lot of examples, we will create a simple example to light the screen. And privde all the necessary setup to use the lvgl library in a single file. Hope it will help you to understand how the lvgl library works.

```c
#include <Arduino.h>

#include <TFT_eSPI.h> // Graphics and font library for ILI9341 driver chip
#include <lvgl.h>

/*Change to your screen resolution*/
static const uint16_t screenWidth = 320;
static const uint16_t screenHeight = 240;

static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf[screenWidth * screenHeight / 10];

TFT_eSPI tft = TFT_eSPI(screenWidth, screenHeight); /* TFT instance */

/* Display flushing */
void my_disp_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)
{
  uint32_t w = (area->x2 - area->x1 + 1);
  uint32_t h = (area->y2 - area->y1 + 1);

  tft.startWrite();
  tft.setAddrWindow(area->x1, area->y1, w, h);
  tft.pushColors((uint16_t *)&color_p->full, w * h, true);
  tft.endWrite();

  lv_disp_flush_ready(disp_drv);
}

void setup()
{
  Serial.begin(115200);

  lv_init();

  tft.init();
  tft.setRotation(3);

  lv_disp_draw_buf_init(&draw_buf, buf, NULL, screenWidth * screenHeight / 10);

  /*Initialize the display*/
  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv);
  /*Change the following line to your display resolution*/
  disp_drv.hor_res = screenWidth;
  disp_drv.ver_res = screenHeight;
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  lv_disp_drv_register(&disp_drv);

  /* Create simple label */
  lv_obj_t *label = lv_label_create(lv_scr_act());
  lv_label_set_text(label, ""Hello ESP32Cube!"");
  lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);
}

void loop()
{
  static long last_time = millis();
  if (millis() - last_time > 5)
  {
    last_time = millis();
    lv_timer_handler(); // Call lvgl's timer handler
    lv_tick_inc(5);     // Update lvgl's tick
  }
}
```

Upload the code to the board, and the screen will show a blue background with the text ""Hello ESP32Cube!"".

The code is simple, and it is a good start to understand how the lvgl library works. You can also modify the code to create more complex UIs.

The source code is available at https://github.com/ESP32Cubes/ESP32_UI_tutorial/tree/main/Let02_lvgl.","On this article, we will show you how to install and set up the lvgl library in the ESP32 board.",,2024-11-29 13:36:42.307677,2025-07-28 02:07:10.745386,2115,0,1,2,esp32-with-lvgl-setp2-config-tft_espi-with-platformio,d446577c94a86d996c74fb00992451eb
43,Testing Post,,This is a testing post,,2024-11-29 13:36:42.362985,2025-07-28 01:52:34.373155,577,0,1,2,testing-post,d5627f4aad47f56b3f124a77b240c8cb
44,ESP32 and human body infrared module,"## Introduction

Dear friends, have you ever thought that your room can be as full of mystery and surprises as the castle in fairy tales? Today, we will work with you to use ESP32 to control the human body infrared module to add a bit of unique charm to your room!

## Human body infrared module

First, let’s take a look at this mysterious device.

Human body infrared module: This is a special sensor that can detect human activity and is usually used in smart homes, security monitoring and other fields. It emits infrared signals, and when someone approaches, the receiver detects these signals and triggers an alarm.

![[827bf2a06b6f5d7e89fbcd6cef98f227_MD5.png]]

- **VCC**  is the power supply pin for the IR sensor, which we connect to the 5V pin on the Arduino.
- **OUT** pin is a 5V TTL logic output. LOW indicates no motion is detected; HIGH means motion is detected.
- **GND** Should be connected to the ground of the Arduino.

This sensor can detect the presence of an obstacle in front of it.  
The discovery distance can be adjusted using the onboard trimmer.  

Returned values: digital '1' or '0'.

## Control principle

Human body induction sensors are very common in indoor security applications. The principle is that the detection element converts the infrared radiation detected by the human body into a weak voltage signal, which is amplified and then output. In order to improve the detection sensitivity of the detector and increase the detection distance, a plastic Fresnel lens is usually installed in front of the detector. It cooperates with the amplification circuit to amplify the signal, so that people within a certain range can be detected.

## Common applications

Intelligent induction sanitary ware, home security, robot obstacle recognition, intelligent detection, intelligent control, faucet induction, automatic toilet flushing, automatic hand dryer, anti-theft device, automatic doorbell, stair aisle induction, proximity reminder, automatic door, automatic trash cans (buckets) etc.

## Connect circuit

Just three wires, VCC, GND and a signal wire can be connected to the corresponding GPIO.

The resistances on below figure is optional.

![[e4061ca3852e22205ec19b6960f5bd4e_MD5.png]]

## Code

```c
#include <IRremote.h>

int IRSensor = 9; // connect IR sensor module to ESP32

void setup(){
  Serial.begin(115200); // Init Serial at 115200 Baud Rate.
  pinMode(IRSensor, INPUT); // IR Sensor pin INPUT
}

void loop(){
  int sensorStatus = digitalRead(IRSensor); // Set the GPIO as Input
  if (sensorStatus == 1) // Check if the pin high or not
  {
    Serial.println(""Motion Detected!"");
  }
}
```

In this example, the IRremote library is used, and you can install it using the ""Library Manager"" in the Arduino IDE.

This code prints the hexadecimal value of the received IR signal to the serial monitor. You can modify the code according to your specific requirements. Keep in mind that signals from different IR remotes may vary, so you need to adapt the code based on the signals from your particular remote.

## Summarize

This section implements the detection of human body induction sensors through a simple interrupt method. Human body induction sensors are widely used, especially in the security field. Combined with other hardware modules, when an intrusion is detected, an alarm and remote reminder can be issued. and other functions. You can give full play to your imagination and use the OLED and buzzer on the front to make the alarm function better.

Dear friends, I hope you enjoyed today's tutorial. By learning how to use ESP32 to control the human body infrared module, you can not only create an interesting smart alarm system, but also exercise your hands-on and programming abilities. I hope everyone can find fun in the world of programming and become future technology experts!

If you are interested in other creative projects, please continue to follow and star our official account for more interesting content and tutorials. Don’t forget to forward and share with friends in need!","Usage of ESP32 to control the human body infrared module, covering its components, control principle, applications, circuit connection, and code.",827bf2a06b6f5d7e89fbcd6cef98f227_MD5.png,2024-11-29 13:36:42.383765,2025-07-27 23:34:04.033973,714,0,1,2,esp32-and-human-body-infrared-module,ace70c5541347302af56bed76383177f
45,ESP32 with LVGL Setp1 Config TFT_eSPI with PlatformIO,"While I'm developing a project with a TFT screen, and drive it with TFT_eSPI library, I found that the configuration of the library is not so easy. So I write this article to record the configuration process.

## TFT screen data sheet

The screen shows as below:

![[17dad6bc339cfa3a091070216248643c_MD5.png]]

Specification:

- 2.4 inch TFT LCD
- 240x320 resolution
- 4 wire SPI interface
- dimension: 42.72x60.26X2.4mm
- display area: 37.42x49.66mm
- backlight: 4 white LED, 60mA
- 3~3.3V power supply
- power consumption: 0.22W
- operating temperature: -20~70C
- storage temperature: -30~80C
- viewing angle: 12 o'clock
- driver IC: ST7789

pin define as below:

| #  | Name  | Description    |
| ---- | ------- | ---------------- |
|  1 | GND   | Ground         |
|  2 | RESET | reset          |
|  3 | SCL   | time           |
|  4 | D/C   | data           |
|  5 | CS    | chip selection |
|  6 | SDA   | data           |
|  7 | SDO   | SPI Data out   |
|  8 | VCC   | VCC 3\~3.3C    |
|  9 | A     | LED A          |
| 10 | K     | LED K          |

## TFT_eSPI library

Search the library in the platformIO library manager, and install it.

## Configuration

The configuration is a little bit complex.

First, create a setup file, such as `mysetup.h` under the folder `.pio\libdeps\esp32doit-devkit-v1\TFT_eSPI\`.

`mysetup.h`

```c
// ST7789 240 x 280 display with no chip select line
#define USER_SETUP_ID 24

#define ST7789_DRIVER // Configure all registers

#define TFT_WIDTH 240
#define TFT_HEIGHT 320

// #define TFT_RGB_ORDER TFT_RGB  // Colour order Red-Green-Blue
#define TFT_RGB_ORDER TFT_BGR // Colour order Blue-Green-Red

// #define TFT_INVERSION_ON
#define TFT_INVERSION_OFF

#define TFT_BACKLIGHT_ON HIGH // Level to turn ON back-light (HIGH or LOW)

// Generic ESP32 setup
// #define TFT_MISO 12 不需要
#define TFT_MOSI 13
#define TFT_SCLK 14
#define TFT_CS 15 //-1 Not connected
#define TFT_DC 26
#define TFT_RST 25 // Connect reset to ensure display initialises
#define TFT_BL 27  // LED back-light control pin

#define LOAD_GLCD   // Font 1. Original Adafruit 8 pixel font needs ~1820 bytes in FLASH
#define LOAD_FONT2  // Font 2. Small 16 pixel high font, needs ~3534 bytes in FLASH, 96 characters
#define LOAD_FONT4  // Font 4. Medium 26 pixel high font, needs ~5848 bytes in FLASH, 96 characters
#define LOAD_FONT6  // Font 6. Large 48 pixel font, needs ~2666 bytes in FLASH, only characters 1234567890:-.apm
#define LOAD_FONT7  // Font 7. 7 segment 48 pixel font, needs ~2438 bytes in FLASH, only characters 1234567890:.
#define LOAD_FONT8  // Font 8. Large 75 pixel font needs ~3256 bytes in FLASH, only characters 1234567890:-.
#define LOAD_FONT8N // Font 8. Alternative to Font 8 above, slightly narrower, so 3 digits fit a 160 pixel TFT
#define LOAD_GFXFF  // FreeFonts. Include access to the 48 Adafruit_GFX free fonts FF1 to FF48 and custom fonts

#define SMOOTH_FONT

// #define SPI_FREQUENCY 27000000
#define SPI_FREQUENCY 80000000
#define SPI_READ_FREQUENCY 20000000
#define SPI_TOUCH_FREQUENCY 2500000

// #define SUPPORT_TRANSACTIONS
```

Then modify the file `User_Setup_Select.h` to include the setup file. Comment the line `#include <User_Setup.h>` and add the line `#include ""mysetup.h""`.

```c
// #include <User_Setup.h>
#include ""mysetup.h""
```

So the configuration is done.

However, this way has a disadvantage. The configuration file will be lost if the library is updated or reinstall the library. So there is another way to configure the library.

## Configure the library in PlatformIO Configuration File

The other way is to configure the library in the `platformio.ini` file.

```ini
[env:esp32doit-devkit-v1]
platform = espressif32
board = esp32doit-devkit-v1
framework = arduino
monitor_speed = 115200
lib_deps = 
	bodmer/TFT_eSPI@^2.5.43
build_flags =
  	-D USER_SETUP_LOADED=1
	-D ST7789_DRIVER=1
    -D TFT_WIDTH=240
    -D TFT_HEIGHT=320
	-D TFT_INVERSION_OFF=1
  	-D TFT_MOSI=13
  	-D TFT_SCLK=14
  	-D TFT_CS=15
  	-D TFT_DC=26
  	-D TFT_RST=25
  	-D TFT_BL=27
    -D LOAD_GLCD=1
    -D LOAD_FONT2=1
    -D LOAD_FONT4=1
    -D LOAD_FONT6=1
    -D LOAD_FONT7=1
    -D LOAD_FONT8=1
    -D LOAD_FONT8N=1
    -D LOAD_GFXFF=1
    -D SMOOTH_FONT=1
    -D SPI_FREQUENCY=80000000
```

Of cause, you can also modify the `platformio.ini` file as need base on the screen and the project.

## Main file to test the screen

After setup the library, we can write a simple main file to test the screen.

```c
#include <Arduino.h>

#include <TFT_eSPI.h> // Graphics and font library for ILI9341 driver chip
#include <SPI.h>

TFT_eSPI tft = TFT_eSPI(); // Invoke library

void setup()
{
  Serial.begin(115200);

  tft.init();
  tft.setRotation(3);
}

void loop()
{
  tft.fillScreen(TFT_BLUE);
  tft.setCursor(50, 50, 4);
  tft.setTextColor(TFT_WHITE);
  tft.println(""Hello ESP32Cube!"");
  delay(2000);
}
```

upload the code to the board, and the screen will show a blue background with the text ""Hello ESP32Cube!"".

Source code link: [ESP32_UI_tutorial/Let01_TFT_eSPI at main · ESP32Cubes/ESP32_UI_tutorial (github.com)](https://github.com/ESP32Cubes/ESP32_UI_tutorial/tree/main/Let01_TFT_eSPI)","This article walks through the configuration process of the TFT_eSPI library for a 2.4 inch TFT display powered by the ESP32, detailing setup steps in both a custom header file and the PlatformIO configuration file.",17dad6bc339cfa3a091070216248643c_MD5.png,2024-11-29 13:36:42.401003,2025-07-28 02:07:10.470140,1772,0,1,2,esp32-with-lvgl-setp1-config-tft_espi-with-platformio,5fe6c6c2ea2396666f79eac6dee7dadb
46,SY8303 Synchronous Step Down Regulator DCDC Circuit Design,"In this article, it will introduce the design of the SY8303 synchronous rectification Buck step-down chip circuit, including the schematic and PCB drawing processes, as well as the precautions and techniques.
## Introduction of SY8303 Chip 

SY8303 is a synchronous rectification Buck step-down chip, with TSOT23-8 package. The input voltage ranges from 4.5V to 40V, the maximum output current is 3A, the reference voltage is 0.6V, the output voltage is from 0.6V to 0.9Vin, and the switching frequency ranges from 500kHz to 2.5MHz.

Advantageous features: It offers low cost and high performance. It has low RDS(ON) for internal switches (top/bottom): 110/70 mΩ.

In this post it will use SY8303 to design a 24V to 12V, 2.5A, 500KHz DCDC converter. The design follows the guidance of https://www.bilibili.com/video/BV1abUdYGEfv/. Thanks to Mr Tang.

## Design Key Points

### About the Frequency

The heating of DCDC chips is a critical issue. The heat consisted of the switching losses, conduction resistance losses, loss of magnetic components(inductor) and capacitor losses.

The conduction loss is regardless of the switching frequency is high or low,  is equal. But when the switching frequency is high, the switching loss will increase.

The higher the switching frequency is the inductor value will be smaller. However, the switching loss will be greater, and the chip will generate more heat, the chip will become hotter. 

Therefore, it is necessary to select the switching frequency carefully, and the inductor value should be selected to be a little smaller than the rated current. 

So personally, suggest setting the switching frequency at 500KHz.

### Capacitor selection

Input capacitor CIN: It is recommended to use a combination of large and small capacitances in parallel. The large capacitance has a voltage withstand of 35V and can be selected as 47μF, and the small capacitance is 0.1μF, placed close to the VIn and GND pins.

Output capacitor COUT: Also use a combination of large and small capacitances in parallel, with a voltage withstand of 25V. The capacity can be selected as 22μF, with the large capacitance close to the chip and the small capacitance beside the large one.

Bootstrap capacitor CBS: Has a value of 100nF and is placed close to the BS and LX pins.

### Resistance settings

Feedback resistors R1 and R2: The value range is 10K - 1MΩ and are used to set the output voltage. For example, to output 12V, 15K and 280K resistors can be selected.

Switching frequency setting resistor RFS: The switching frequency equals to: Fsw = 10^5/RFS kHz, where RFS is in kΩ. If the switching frequency is set to 500KHz, RFS is 200KΩ.

Feedforward capacitor (optional): Can be paralleled on R3 and has a value as small as possible, such as 30pF.

The schematic shows as below figure:

![[Pasted image 20241204094843.jpeg]]

### Other key points

- Under-voltage protection: If under-voltage protection is not required, pins 1 and VR can be connected together or through a small resistor, but the resistor should not be too large.
- Switching frequency: A low switching frequency results in less heat generation for the chip, but a larger inductance is required; a high switching frequency requires a smaller inductance, but the chip has higher switching losses and significant heat generation.
- Inductor selection: The inductance value needs to be calculated based on the input and output voltages, current, and switching frequency. The rated current should be greater than or equal to 1.2 times the maximum IO. For example, when the input is 24V, the output is 12V, the current is 2.5A, and the switching frequency is 500KHz, an inductor of 15μH and a rated current of 4.5A can be selected.

## Layout

- Place capacitors, including CI (0.1μF and 47μF), CEO (25V 22μF), CBS (100 nF), etc. Pay attention to the capacitor package and voltage withstand value.
- Place the inductor and select the appropriate inductance value and rated current based on the calculation.
- Place resistors such as R1, R2, and RFS, and set the corresponding resistance values.


- During layout, place CI close to the VI and GND pins, CBS close to the BS and LX pins, and the resistors connected to the FB close to the FB pin. The VO sampling point is after the last capacitor.
- Perform special processing on the SW pin, such as expanding the copper area of the pin, opening windows, and tinning to aid in heat dissipation.
- Add polygons on the top solder mask layer and expose copper for heat dissipation of the SW pin and inductor.

Wiring and copper plating

- Select an appropriate wire width for wiring, such as 8 mil or 10 mil, to ensure smooth traces.
- Switch to the bottom and top layers for copper plating, set the direct connection network rules with a spacing of 12 mil, and complete the copper plating.
- Place vias at positions such as CI and CEO, with an inner diameter of 12 mil, an outer diameter of 24 mil, and a row spacing of 40 mil to connect the top and bottom layers to assist in heat dissipation of the chip.

## Precautions and Techniques

- Avoid common mistakes: Small values of CI and CO may lead to unstable output voltage and other issues.
- Improve technical content: For example, leave a gap at C7 to force the current through the filter capacitor.","This post introduces the design of the DCDC chip SY8303 circuit, covering the schematic and PCB drawing processes, along with precautions and tips.",,2024-12-02 14:19:21.684593,2025-07-28 01:18:53.650194,916,0,1,4,sy8303-synchronous-step-down-regulator-dcdc-circuit-design,575749ad7d3cdd4c73ceb99b75c759f2
47,Obsidian remove strikethrough on completed tasks,"The default task style in obsidian like this, there is a strikethrough for the done task. That will effect the reading. If we want to remove the strikethrough, it can be done by provide a customer .css file.

```
1. [x] Do first step. There are some task need to do in first step. For example, testing with bad samples. ✅ 2024-12-20
2. [ ] Do next step
3. [ ] Do following step
```

Default style
![[Pasted image 20241220092046.jpeg]]

We can remove the strikethrough style by add below css style.

**create a .css file under folder .obsidian\snippets**

```css
.markdown-source-view.mod-cm6 .HyperMD-task-line[data-task=""x""],
.markdown-source-view.mod-cm6 .HyperMD-task-line[data-task=""X""] {
    text-decoration: none;
    color: inherit;
}
```

and in the setting --> Appearance --> CSS snippets, active the css file. Here is the ceckboxes.css

![[Pasted image 20241220141348.jpeg]]

Then the to do list will looks like:

![[Pasted image 20241220092350.jpeg]]",This post shows how to remove strikethrough on completed tasks in Obsidian.,,2024-12-20 06:30:09.496647,2025-07-28 01:22:42.388885,1029,0,1,2,obsidian-remove-strikethrough-on-completed-tasks,51823168911e9457122caa48efba37e4
48,ESP32 WROOM Pin Name High Resolution,"In this post, we will provide the pin name of ESP32 WROOM module in high resolution.

## ESP32 WROOM Module Pin Name

![[ESP32_Wroom.jpeg]]

## ESP32 DevKitC Development Board Pin Name

![[ESP32_DevkitC.jpeg]]

When using this diagram, ensure it matches your specific ESP32 WROOM module version, as pin configurations may vary between different models.

And some of ESP32 development boards may have different pin account and pin names, so please refer to the documentation provided by the manufacturer for the correct pin names.

The pdf files can be downloaded from the following link:

[ESP32 WROOM Pin Name](https://esp32cube.com/uploadsESP32_Wroom.pdf)

[ESP32 DevKitC Pin Name](https://esp32cube.com/uploadsESP32_DevkitC.pdf)

If you want to know the detail function of each pin, please ref to [ESP32 DEVKIT V1 Pin Referance](https://esp32cube.com/post/esp32-devkit-v1-pin-referance/)",This post provides the pin name of ESP32 WROOM module and ESP32 DevKitC development board in high resolution and also provides the pdf file for download.,ESP32_Wroom.jpeg,2024-12-30 12:29:45.011987,2025-07-28 00:43:06.927789,853,0,1,2,esp32-wroom-pin-name-high-resolution,6d0cd12de9e5b201d54c402494155173
49,ESP32 Voice Record and upload,"## Hardware

INMP441
![[Pasted image 20250118201558.jpeg]]

SCK -> GPIO 14 (I2S Clock)
WS -> GPIO 15 (I2S Word Select)
SD -> GPIO 32 (I2S Data)
ESP32 GND -> INMP441 GND
ESP32 VIN (3.3V) -> INMP441 VIN

## Software

```c
#include <driver/i2s.h>

#define I2S_NUM           I2S_NUM_0
#define I2S_BCK_PIN       14  // I2S Clock (SCK)
#define I2S_WS_PIN        15  // I2S Word Select (WS)
#define I2S_DO_PIN        -1  // I2S Data Out (unused)
#define I2S_DI_PIN        32  // I2S Data In (SD)

void setup() {
  Serial.begin(115200);

  // Configure I2S settings
  i2s_config_t i2s_config = {
    mode: I2S_MODE_MASTER | I2S_MODE_RX,  // Master mode, receive data
    sample_rate: 44100,                   // Audio sample rate (44.1 kHz)
    bits_per_sample: I2S_BITS_PER_SAMPLE_16BIT,  // 16-bit per sample
    channel_format: I2S_CHANNEL_FMT_ONLY_RIGHT,  // Mono data (only right channel)
    communication_format: I2S_COMM_FORMAT_I2S_MSB,  // I2S MSB format
    intr_alloc_flags: ESP_INTR_FLAG_LEVEL1,
    dma_buf_count: 8,  // Number of DMA buffers
    dma_buf_len: 64,   // Length of each buffer
  };

  // Configure I2S pin mapping
  i2s_pin_config_t pin_config = {
    bck_io_num: I2S_BCK_PIN,
    ws_io_num: I2S_WS_PIN,
    data_out_num: I2S_DO_PIN,
    data_in_num: I2S_DI_PIN
  };

  // Install I2S driver
  i2s_driver_install(I2S_NUM, &i2s_config, 0, NULL);
  i2s_set_pin(I2S_NUM, &pin_config);
  
  Serial.println(""I2S setup complete"");
}

void loop() {
  uint8_t i2s_data[64];  // Buffer to hold audio data

  // Read data from I2S interface
  size_t bytes_read;
  i2s_read(I2S_NUM, &i2s_data, sizeof(i2s_data), &bytes_read, portMAX_DELAY);

  // Print the number of bytes read
  Serial.print(""Received bytes: "");
  Serial.println(bytes_read);

  // Process or save the audio data here as needed
}
```


```mermaid
graph TD;
    A[开始] --> B[创建默认事件循环];
    B --> C[初始化 NVS 存储];
    C --> D{初始化成功?};
    D -- 否 --> E[输出日志警告并擦除 NVS];
    E --> C;
    D -- 是 --> F[启动应用程序];
    F --> G[进入循环];
    G --> H[延迟 10 秒];
    H --> I[获取内部堆内存信息];
    I --> J[输出内部堆内存信息];
    J --> G;
```",,,2025-01-26 08:19:37.458222,2025-07-27 19:56:39.053390,615,0,1,2,esp32-voice-record-and-upload,80a105a6a5ecca88e6306c7e4a06e84b
50,Set Proxy for Ollma on Windows,"If you are work behind a proxy, Ollama will unable to pull models behind the proxy on windows. Here is the solution for it.

Actually, it's very simple to set proxy for Ollama on windows. Just need to add a new environment variable named `HTTPS_PROXY` with your proxy address.

Show as below figure

![[Pasted image 20250208165154.jpeg]]

Then open PowerShell and type: 

```
ollama run deepseek-r1:7b
```

It will pull the model from the proxy.

![[Pasted image 20250208165718.jpeg]]

That all.

There are several discussions about this issue on the web, but no one can provide a clear solution. And please note that no need to add environment variable `HTTP_PROXY`, it may interrupt client connections to the server.",Set proxy for ollama on Windows,,2025-02-08 09:02:14.904759,2025-07-27 21:43:57.293116,3320,0,1,2,set-proxy-for-ollma-on-windows,012a739f141793fa2ddf13fc8e01c389
51,How to Play Internet Radio Stations with ESP32,"## Introduction

In this tutorial, we will be using an ESP32-S3 to play internet radio stations. First, we need connect the ESP32-S3 to the internet using a WiFi module. Then, we will use the `audio` library to stream the radio station's audio to the ESP32-S3.

## Step 1: Connect the ESP32-S3 to the internet

In order to make things simple, we will configure the Wifi ID and password in code.

```c
#include ""Arduino.h""
#include <WiFi.h>

String ssid =     ""*****"";
String password = ""*****"";

void setup() {
  Serial.begin(115200);

  WiFi.begin(ssid.c_str(), password.c_str());
  while (WiFi.status()!= WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }
  
  Serial.println("""");
  Serial.println(""WiFi connected"");
  Serial.print(""IP address: "");
  Serial.println(WiFi.localIP());
}

void loop() {
  // put your main code here, to run repeatedly:
}
```

## Step 2: Install the `audio` library

The `audio` library is a powerful library that allows us to stream audio data to the ESP32-S3. We will use this library to stream the radio station's audio to the ESP32-S3.

To install the `audio` library, we need to add it to the `platformio.ini` file.

```ini
[env:esp32dev]
platform = espressif32
board = esp32dev
framework = arduino
lib_deps = audio
```

## Step 3: Stream the radio station's audio to the ESP32-S3

Now, we will use the `audio` library to stream the radio station's audio to the ESP32-S3.

```c
#include ""Arduino.h""
#include <WiFi.h>
#include <audio.h>

#define I2S_DOUT            9
#define I2S_BCLK            3
#define I2S_LRC             1

String ssid =     ""*****"";
String password = ""*****"";

Audio audio;

void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  while (WiFi.status()!= WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }

  Serial.println("""");
  Serial.println(""WiFi connected"");

  audio.setPinout(I2S_BCLK, I2S_LRC, I2S_DOUT);
  audio.setVolume(64);

// radio station's audio stream URL
    audio.connecttohost(""http://stream.antennethueringen.de/live/aac-64/stream.antennethueringen.de/""); // aac
}

void loop() {
    audio.loop();
    vTaskDelay(1);
}
```

In the `setup()` function, we initialize the `audio` library and set the output and input devices to `AUTO`. Then, we start the radio station's audio stream using the `audio_stream_start()` function.

In the `loop()` function, we start the radio station's audio stream using the `audio_stream_start()` function and then stop it after 10 seconds using the `audio_stream_stop()` function.

## Conclusion
In this tutorial, we have learned how to use the `audio` library to stream internet radio stations to the ESP32-S3. We have also learned how to connect the ESP32-S3 to the internet using a WiFi module.",This post provides a step-by-step guide of play Internet radio on an ESP32-S3.,,2025-02-09 03:53:25.628882,2025-07-27 22:43:59.459587,947,0,1,2,how-to-play-internet-radio-stations-with-esp32,bdcc699bbd1ecaf8a328f5303d57c28c
53,Audio Playback with HSC001 and ESP32,"## Introduction

Curious about audio playback in electronics? Let’s start with the **HSC001 module**—a compact, cost-effective 24-bit audio player with versatile applications like elevator music, device sound effects, and more. In this guide, we’ll explore how to configure and play audio files using the HSC001 with an **ESP32 development board**.  


## Components Needed  
- **HSC001 Serial Voice Module**  
- **ESP32 Development Board**  
- **Micro USB OTG Cable**  
- **Jumper Wires**  

## HSC001 Module Overview  
The HSC001 is a playback chip supporting **MP3/WAV formats**, **USB/SPI FLASH storage**, and **FAT16/FAT32 file systems**. Key features:  
- Simple serial command control  
- Direct USB-to-SPI FLASH audio uploading  
- 3W speaker output  
- Low-voltage operation (3.3–5.4V)  
- Reliable and user-friendly  

![[Pasted image 20250415194607.jpeg]]

## Pin Configuration  
The HSC001 has 10 pins:  
1. **SP+**: Amplifier positive (3W max)  
2. **GND**: Ground  
3. **VDD**: Power input (3.3–5.4V)  
4. **SP-**: Amplifier negative  
5. **MUTE**: Mute control  
6. **DP**: USB-DP  
7. **DM**: USB-DM  
8. **ADK**: ADK button  
9. **TX**: UART output (3.3V TTL)  
10. **RX**: UART input (3.3V TTL)  

![[Pasted image 20250415194629.jpeg]]
## Audio Playback with ESP32  
#### **Hardware Setup**  
1. Power the HSC001 via ESP32’s 3.3V output.  
2. Connect ESP32’s **TX** to HSC001’s **RX** (3.3V logic compatible).  
3. Attach a speaker to **SP+/SP-**.  
4. Insert a USB drive with audio files (named `0001.mp3`, `0002.wav`, etc.) into the HSC001.  


## Command Protocol  
Commands follow this structure:  
`[0x7E] + [Len] + [CMD] + [Param1] + [Param2] + [0xEF]`  
- **Len**: Total bytes after Len (excluding start/end bytes).  
- **CMD**: Play, pause, volume, etc.  
- **Params**: Command-specific arguments.  

**Example**: Play file `0001` → `7E 04 41 00 01 EF`  


## ESP32 Code  
Upload this code to cycle through audio files every 10 seconds:  
```cpp
byte currentSound = 0x01;  // Start with file 0001

void setup() {
  Serial.begin(9600);      // ESP32 UART1 (adjust pins if needed)
}

void loop() {
  // Send play command
  Serial.write(0x7E);
  Serial.write(0x04);      // Len = 4 (CMD + 2 params)
  Serial.write(0x41);      // CMD: Play by index
  Serial.write(0x00);      // Param1: High byte (00)
  Serial.write(currentSound); // Param2: Low byte (file number)
  Serial.write(0xEF);      // End byte

  delay(10000);            // Play for 10 seconds
  currentSound++;          // Next file
  if (currentSound > 10) currentSound = 1; // Reset after file 10
}
```


## Code Breakdown  
1. **UART Initialization**: ESP32 communicates at 9600 baud.  
2. **Command Structure**:  
   - `0x7E` and `0xEF` mark start/end.  
   - `0x41` triggers playback by file index.  
3. **File Cycling**: Increments `currentSound` every 10 seconds (adjust delay as needed).  


## Troubleshooting Tips  
- Ensure audio files are named `0001`, `0002`, etc., and formatted as FAT32.  
- Confirm wiring matches ESP32’s 3.3V logic (no level shifter needed).  
- Check serial port configuration (e.g., use `Serial1` if ESP32’s default UART is busy).","This post is an introduction to using the HSC001 module for audio playback. It details the necessary components, module features, pin distribution, hardware connections, and code implementation for setting up and playing audio files.",,2025-04-15 11:49:12.281209,2025-07-28 01:36:21.556796,417,0,1,2,audio-playback-with-hsc001-and-esp32,068f088d97d1bbea820bbfe4f2da4913
54,TRMNL A Wireless E-Ink Display Powered by ESP32-C3,"TRMNL is a 7.5-inch wireless black-and-white E-Ink display powered by the ESP32-C3 RISC-V Wi-Fi and Bluetooth SoC. It features a customizable design that allows users to disassemble the device, modify its open-source firmware, and access API keys.

![[06b44103db4591d34b00532b91b9ac77_MD5.webp]]

The device comes with a default 1,800mAh battery that lasts over 3 months on a single charge. Alternatively, a 2,500mAh battery is available, extending the usage time to over 6 months. TRMNL can be placed on a desk or mounted on a wall or refrigerator. The device includes a case opener, with optional accessories like a USB-C cable, screen protector, and microfiber cloth.

### TRMNL Specifications:
- **Wireless MCU**: Espressif ESP32-C3
- **Display**: 7.5-inch black-and-white E-Ink display with a resolution of 800 x 480
- **Battery**: 1,800mAh rechargeable lithium battery (upgradeable to 2,500mAh for 6+ months of usage)
- **Dimensions**: 171 x 116 x 10mm
- **Weight**: 165g
- **Case**: Soft-touch ABS (black only), chrome-plated steel bracket

![[06b44103db4591d34b00532b91b9ac77_MD5.webp]]

#### GitHub Repository:
[TRMNL Firmware on GitHub](https://github.com/usetrmnl/trmnl-firmware)

#### API Documentation:
[TRMNL API Docs](https://docs.usetrmnl.com/go/how-it-works)

The firmware, API documentation, and power consumption measurement details are all open-sourced. The API documentation site provides more detailed explanations of the firmware and software design. Essentially, the system works by implementing communication between the client and server, where the TRMNL firmware sends requests to the server for content, plugins, or firmware updates.

### Plugins and Customization
The server hosts a collection of native and custom plugins. TRMNL plugins can display RSS feeds, show photo slideshows, weather updates, Bitcoin or Ethereum wallet balances, Outlook or Google calendars, Hacker News feeds, shopping lists, and more. Currently, there are 82 plugins available (as shown below).

![[06b44103db4591d34b00532b91b9ac77_MD5.webp]]

For DIY enthusiasts, TRMNL also supports the inclusion of third-party libraries like Highcharts, allowing you to create data visualizations such as line graphs and charts.

![[06b44103db4591d34b00532b91b9ac77_MD5.webp]]

---

This content is ideal for makers, engineers, and anyone interested in wireless display technologies, offering easy customization and a wide range of use cases through open-source hardware and software.","TRMNL is a wireless 7.5-inch black-and-white E-Ink display based on the ESP32-C3 RISC-V SoC, offering customizable features, open-source firmware, and API access. It's perfect for DIYers and makers.",,2025-06-24 11:36:52.963439,2025-07-27 22:28:54.027392,279,0,1,1,trmnl-a-wireless-e-ink-display-powered-by-esp32-c3,75d0721d209e4a5fe07865898b2c3511
55,Pomodoro Timer Based on ESP32 with E-Ink Display,"## Pomodoro Timer Based on ESP32

The Pomodoro Technique is an effective time management method that uses intervals of work and rest to improve focus and productivity. This timer is based on ESP32, featuring a 4.26-inch black-and-white E-Ink display and an input via a rotary encoder.

![[a1ddfacc2c19a7ab211d49fe3782a146_MD5.webp]]

### GitHub Repository:
[Pomodoro Timer GitHub](https://github.com/Rukenshia/pomodoro)

This project is mostly open-source software, and the hardware is modular, requiring simple wiring.

### Main Components:

- **ESP32** (AZDelivery ESP32 NodeMCU, based on the ESP32-WROOM-32; an older model that might have been discontinued)
- **Waveshare 4.26-inch E-Ink Display** with a resolution of 800x480 (The choice of black-and-white E-Ink is due to its 0.3s refresh speed and static display, which doesn't interfere with your focus while working)
- **KY-040 Rotary Encoder with buttons**
- **WS2812 RGB LED** (can be replaced with a simple RGB LED)
- **USB-C Interface** (Type-C Female)
- **3D Printed Enclosure**
- **Some resistors and 0.1uF capacitors**

### Pin Connections:

#### KY-040 Rotary Encoder:
| Pin  | ESP32 Pin |
|------|-----------|
| CLK  | 32        |
| DT   | 21        |
| SW   | 14        |

#### 4.26-inch E-Ink Display:
| Pin  | ESP32 Pin |
|------|-----------|
| BUSY | 4         |
| RST  | 16        |
| DC   | 17        |
| CS   | 5         |
| CLK  | 18        |
| DIN  | 23        |

#### LED (WS2812):
| Pin  | ESP32 Pin |
|------|-----------|
| DIN  | 25        |

### Software:
The software is written in C++ using the Arduino framework, and the project is managed with PlatformIO. It relies heavily on the **GxEPD2** library. For more details, please refer to the GitHub repository.

### 3D Printed Enclosure:

![[Pasted image 20250624194515.jpeg]]

### How It Works:
Upon starting the device, you can adjust settings or enter the preset selection mode. From there, you can choose from three predefined timer modes.

![[Pasted image 20250624194545.jpeg]]

The timer will then start and notify you when the time is up (by flashing the LED and showing a message on the screen). You can continue working (though not recommended), then start your break.

![[Pasted image 20250624194612.jpeg]]

During the breaks, you can check some statistics. After a few iterations (default is 4), your break time will be longer, giving you time to recover.

![[Pasted image 20250624194606.jpeg]]","This is a Pomodoro timer based on ESP32 with a 4.26-inch black-and-white E-Ink display, featuring a rotary encoder for input. The timer helps manage work and break intervals efficiently.",,2025-06-24 11:46:49.225011,2025-07-27 22:28:57.087415,231,0,1,1,pomodoro-timer-based-on-esp32-with-e-ink-display,0e1a014d16d1c101cbe8d8cd5159826b
56,ESP32-P4-EYE A Development Kit for AI Vision Applications,"## ESP32-P4-EYE: A Development Kit for AI Vision Applications

The **ESP32-P4-EYE** is a development kit based on the ESP32-P4 chip, designed specifically for AI vision applications. It looks similar to a standard camera and offers a rich set of peripherals, including a camera, microphone, LCD, USB ports, and more.

![[14e9b12b90b2fbccc2c08fd0bbab4c7c_MD5.webp]]

### GitHub Repository:
[ESP32-P4-EYE GitHub](https://github.com/espressif/esp-dev-kits/tree/0b833fe32cc46f48ce4499d1b602628f3660eba7/examples/esp32-p4-eye)

The documentation is quite comprehensive, including schematics, PCB layouts, and a code example for a mini camera application. This application supports photo capture, timed photo capture, video recording, gallery preview, SD card installation, and a settings interface with adjustable resolution, saturation, contrast, brightness, and hue.

### Key Features:
- **Dual-core 400 MHz RISC-V Processor** with support for up to 32MB PSRAM.
- **Supports USB 2.0**, MIPI-CSI/DSI, and H264 Encoder.
- **ESP32-C6-MINI-1U** module for Wi-Fi (Wi-Fi 6), Bluetooth, Zigbee, and Thread communication.
- **Camera Interface** (MIPI-CSI) and **USB 2.0 High-Speed Slave Mode**.
- **Onboard Camera**, Display, Microphone, and MicroSD Card support.
- **Rotary Encoder** for controlling LCD menus and adjusting zoom.
- **USB or Battery-powered**.

### Functional Block Diagram:

![[Pasted image 20250624195147.jpeg]]
### Component Descriptions:

![[Pasted image 20250624195359.png]]

#### ESP32-P4-EYE PCB Overview:

![[Pasted image 20250624195405.png]]

#### Key Components:

| **Component**             | **Description** |
|---------------------------|-----------------|
| **MicroSD Card Slot**      | Supports 4-wire SDIO and SPI mode for MicroSD cards. |
| **Test Points**            | Provides access points for programming and testing the ESP32-C6-MINI-1U, which can be connected via Dupont wires. |
| **USB 2.0 Device Port**    | Connects to the ESP32-P4's USB 2.0 OTG high-speed interface, adhering to USB 2.0 specifications. This port can also be used to power the development board. |
| **USB Debugging Port**     | For board power, firmware flashing, and connecting to the ESP32-P4 via USB-Serial-JTAG interface. |
| **Power Switch**           | Toggle to ""I"" to power on with a 5V input, and ""O"" to power off. |
| **User-Defined Button**    | Can be customized by the user for specific functions. |
| **LCD FPC Connector**      | Connects to a 1.54-inch LCD screen. |
| **LCD Screen**             | A 1.54-inch LCD with a 240×240 resolution and SPI interface, capable of displaying real-time camera images. |
| **Charging Indicator**     | Red when charging, green when charging is complete. |

#### ESP32-P4-EYE Back View:
![Back View](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

| **Component**             | **Description** |
|---------------------------|-----------------|
| **Rotary Encoder**         | Customizable for controlling the LCD interface or adjusting camera zoom. |
| **ESP32-C6-MINI-1U**       | Serves as the Wi-Fi and Bluetooth communication module. |
| **Fill/Flashlight**        | Provides illumination for image capture and video recording. |
| **Digital Microphone**     | Used for voice recognition or audio recording. |
| **MIPI CSI Connector**     | Connects to the camera module. |
| **Female Header**          | 2 x 10P header, customizable for your application. |
| **SPI Flash**              | 16MB flash memory connected via SPI interface. |
| **ESP32-P4 Series**        | A high-performance MCU with large memory, supporting advanced image and audio processing. |
| **Battery Connector**      | Connects to a lithium battery. |
| **Reset Button**           | Resets the board. |
| **Boot Button**            | Used for entering boot mode. Press while holding down the **Boot Button** to reset the ESP32-P4 and enter firmware download mode. |
| **Camera**                 | 2 MP resolution with manually adjustable focus. |

### Application Scenarios:
This development board can be used in various AI vision applications such as:

- **Smart Surveillance**: With the camera and microphone, it can be used to capture images and audio for monitoring and security.
- **Edge AI for Vision**: Perform real-time image detection and AI processing directly on the device.
- **IoT Integration**: Ideal for integrating into an IoT system for remote monitoring, control, and data collection.

### Innovation and Ecosystem:
Espressif has truly excelled in making the ESP32-P4-EYE an open and innovative development platform. The ecosystem around the ESP32 series is thriving with plenty of support for new applications.","The ESP32-P4-EYE is a development kit based on the ESP32-P4 chip, designed for AI vision applications. It offers various features including a 2MP camera, USB connectivity, and a rich set of peripherals.",,2025-06-24 13:45:57.465346,2025-07-27 22:28:53.042223,233,0,1,1,esp32-p4-eye-a-development-kit-for-ai-vision-applications,8c88da5741a4135c6631b709d2d77177
